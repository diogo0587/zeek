# See the file "COPYING" in the main distribution directory for copyright.

# This file contains templates used to generate virtual functions, opcodes,
# and evaluation code for compiled code.  Each template describes a ZAM
# "operation", which generally corresponds to a set of concrete ZAM
# "instructions".  (See ZInst.h for the layout of ZAM instructions.)  Often
# a single ZAM operation gives rise to a family of instructions that differ
# in either the nature of the instruction's operands (typically, whether
# they are variables residing on the ZAM execution frame, or constants)
# and/or the Zeek type of the operands (e.g., "count" or "double" or "addr").
#
# The Gen-ZAM utility processes this file to generate numerous C++ inclusion
# files that are then compiled into Zeek.  These files span the range of (1)
# hooks that enable run-time generation of ZAM code to execute ASTs (which
# have first been transformed to "reduced" form), (2) specifications of the
# properties of the different instructions, (3) code to evaluate (execute)
# each instruction, and (4) macros (C++ #define's) to aid in writing that
# code.  See Gen-ZAM.h for a list of the different inclusion files.
#
# Operation templates are declarative, other than the imperative C++ snippets
# they include for instruction evaluation/execution.  You specify a template
# using lines of text for which, for the most part, the first word on the
# line designates an "attribute" associated with the template, and the
# remainder of the line provides specifiers/arguments for that attribute.
# A blank line (or end of file) ends the template.  By convention, for
# templates that include C++ evaluation snippets, those are specified as the
# last attribute.  Comments begin with '#' at the start of the line (no
# leading whitespace allowed), and can be intermingled with a template's
# attributes.
#
# Each ZAM instruction includes up to 4 integer values and one constant
# (specified as a ZVal).  Often, the integer values are interpreted as offsets
# ("slots") into the ZAM execution "frame", though sometimes they have other
# meanings, such as the offset of a particular field in a record, or an index
# into the ZAM code for a branch instruction.  Most instructions compute
# some sort of result (expressed as a ZVal) that is stored into the frame
# slot specified by the instruction's first integer value.  We refer to this
# target as the "assignment slot", and to the other 3 integer values as
# "operands".  Thus, for example, an instruction with two operands used the
# first 3 integer values, the first as the assignment slot and the other two
# for computing the result to put in that slot.
#
# The first attribute of each template states the type of operation specified
# in the template, along with the name of the operation.  The possible types
# are:
#
# 	op	an operation that generally corresponds to a single ZAM
# 		instruction, and is fully specified
#
# 	expr-op	an operation corresponding to an AST expression node
# 		(some sort of Expr object).  Gen-ZAM generates code for
# 		automatically converting Expr objects to ZAM instructions.
#		The name of the operation must match that used in the AST
#		tag, so for example for "expr-op Foo" there must be a
#		corresponding "EXPR_FOO" tag.
#
# 	unary-expr-op	an expr-op for a unary Expr object
# 	binary-expr-op	an expr-op for a binary Expr object
# 	rel-expr-op	an expr-op for a (binary) Expr object that
# 			represents a relational operation
#
# 	assign-op       directly assigning either a ZVal or a record field
# 			to either a frame slot or a record field
#
# 	unary-op        an operation with one operand that requires special
# 			treatment that doesn't fit with how unary-expr-op's
# 			are expressed
#
# 	direct-unary-op an operation with one operand that corresponds to
# 			a specific ZAMCompiler method for generating its
# 			instruction
#
# 	internal-op	similar to "op", but for ZAM instructions only used
# 			internally, and thus not having any AST counterpart
# 	internal-binary-op	the same, for operations that take two operands
# 	internal-assignment-op	the same, for operations that assign ZVals
# 				produced by loading interpreter variables
# 				or calling functions
#
# After specifying the type of operation, you list additional attributes to
# fill out the template, ending by convention with the C++ evaluation snippet
# (if appropriate).  The most significant (and complex) of these are:
#
# 	type	specifies how to interpret the operation in terms of ZAM
# 		instruction slots (and constant).  The specification is
# 		in terms of single-letter mnemonics for the different
# 		possible types:
#
# 			F special value designating a record field being
# 			  assigned to
# 			H event handler
# 			L list of values
# 			O opaque value (here, "opaque" refers to ZAM
# 			  internals, not OpaqueVal)
# 			R record
# 			V variable (frame slot)
# 			X used to indicate an empty specifier
# 			i integer constant, often a record field offset
#
# 		The full specification consists of concatenating mnemonics
# 		with the order left-to-right corresponding to each of the
# 		instruction's 4 integer values (stopping with the last one
# 		used).  If the operation includes a constant, then it is
# 		listed at the point reflecting where the constant is used as
# 		an operand.  For example, a type of "VVCV" means that the
# 		first integer is used as a frame variable (i.e., the usual
# 		"assignment slot"), the second integer (first "operand") is
# 		also a frame variable, the second operand is the instruction's
# 		constant, and the third operand is the instruction's third
# 		integer value, with the fourth integer value not being used.
#
# 	op-type for some form of expr-op, specifies to which Zeek scripting
# 		types the expression applies:
#
# 			A addr
# 			D double
# 			F file
# 			I int
# 			N subnet
# 			P pattern
# 			S string
# 			T table
# 			U count
# 			V vector
#
# 		along with two special types: 'X' indicates that Gen-ZAM
# 		should not iterate over any possible values, and '*'
# 		indicates that Gen-ZAM should additionally iterate over
# 		all of possible values not explicitly listed (used in
# 		conjunction with eval-type - see below)
#
# 	eval	specifies a block of C++ code used to evaluation the
# 		execution of the instruction.  The block begins with the
# 		remainder of the "eval" line and continues until either a
# 		blank line or a line that starts with non-whitespace.
#
# 		Blocks can include special '$' parameters that Gen-ZAM
# 		automatically expands.  "$1" refers to an operation's first
# 		operand, "$2" to its second, etc.  "$$" refers to the
# 		operation's assignment target.
#
# 		For simple expr-op's you can express the block as simply
# 		the C++ expression to compute.  For example, for multiplication
# 		(named "Times"), the "eval" block is simply "$1 * $2",
# 		rather than "$$ = $1 * $2"; Gen-ZAM knows to expand it
# 		accordingly.
#
# 		Finally, to help with avoiding duplicate code, you can
# 		define macros that expand to code snippets you want to use
# 		in multiple places.  You specify these using a "macro"
# 		keyword followed by the name of the macro and an evaluation
# 		block.  Macros behave identically to C++ #define's, except
# 		you don't use "\" to continue them across line breaks, but
# 		instead just indent the lines you want included, ending
# 		(as with "eval" blocks) with an empty line or a line that
# 		starts with non-whitespace.
#
# We list the remaining types of attributes alphabetically.  Note that some
# only apply to certain types of operations.
#
# 	assign-val	for an assignment operation, the name of the
# 			C++ variable that holds the value to assign
#
# 	custom-method	a ZAMCompiler method that Gen-ZAM should use for
# 			this operation, rather than generating one
#
# 	eval-mixed	an expression "eval" block that applies to two
# 			different op-type's
#
# 	eval-pre	code to add to the beginning of the "eval" block.
# 			This can be required for operations where Gen-ZAM
# 			generates elements of the C++ (such as for expr-op's).
#
# 	eval-type	evaluation code associated with one specific op-type
#
# 	explicit-result-type	the operation's evaluation yields a ZVal
# 				rather than a low-level C++ type
#
# 	field-op	the operation is a direct assignment to a record field
#
# 	includes-field-op	the operation should include a version
# 				that assigns to a record field as well as a
# 				version for assigning to a frame variable
#
# 	indirect-call	the operation represents an indirect call (through
# 			a global variable, rather than directly).  Only
#			meaningful if num-call-args is also specified.
#
# 	indirect-local-call	same, but via a local variable rather than
#			global
#
# 	method-post	C++ code to add to the end of the method that
# 			dynamically generates ZAM code
#
# 	no-const	do not generate a version of the unary-expr-op
# 			where the operand is a constant
#
# 	no-eval		this operation does not have an "eval" block
# 			(because it will be translated instead into internal
# 			operations)
#
# 	num-call-args	indicates that the operation is a function call,
# 			and specifies how many arguments the call takes.
# 			A specification of 'n' means "build a ZAM instruction
# 			for calling with an arbitrary number of arguments".
#
# 	op-accessor	tells Gen-ZAM what ZVal accessor to use to get to
# 			the underlying values of the operand(s)
#
# 	op1-accessor	the same as op-accessor except only for the first
# 			operand
#
# 	op1-internal    states that the operation's treatment of the
# 			instruction's first integer value is for internal
# 			purposes; the value does not correspond to a frame
# 			variable
#
# 	op1-read	the operation treats the instruction's first integer
# 			value as a frame variable, but only reads the value.
# 			(The default is that the frame variable is written
# 			to but not read.)
#
# 	op1-read-write	the operation treats the instruction's first integer
# 			value as a frame variable, and both reads and
# 			writes the value.
#
# 	op2-accessor	the same as op-accessor except only for the second
# 			operand
#
# 	set-type	the instruction's primary type comes from either the
# 			assignment target ("$$"), the first operand ("$1"),
# 			or the second operand ("$2")
#
# 	set-type2       the same as set-type but for the instruction's
# 			secondary type
#
# 	side-effects	the operation has side-effects, so even if its
# 			assignment target winds up being "dead" (the value is
# 			no longer used), the operation should still occur.
# 			Optionally, this attribute can include two arguments
# 			specifying the ZAM opcode to use if the assignment
# 			is dead, and the internal "type" of that opcode.
#
# 			For example, "side-effects OP_CALL1_V OP_V" means
# 			"this operation has side-effects; if eliminating
# 			its assignment, change the ZAM op-code to OP_CALL1_V,
# 			which has an internal type of OP_V".
#
# 	vector          generate a version of the operation that takes
# 			vectors as operands


# The following abstracts the process of creating a frame-assignable value.
macro BuildVal(v, t) ZVal(v, t)

# Returns a memory-managed-if-necessary copy of an existing value.
macro CopyVal(v) (ZVal::IsManagedType(z.t) ? BuildVal((v).ToVal(z.t), z.t) : (v))

# Managed assignments to "lhs" (generally, frame[z.v1]).
macro AssignV1T(lhs, v, t) {
	if ( z.is_managed )
		{
		/* It's important to hold a reference to v here prior
		   to the deletion in case lhs points to v. */
		auto v2 = v;
		ZVal::DeleteManagedType(lhs);
		lhs = v2;
		}
	else
		lhs = v;
	}
# Convenience macro for when the value of the assigned type comes from
# the instruction.
macro AssignV1(v) AssignV1T(frame[z.v1], v, z.t)
macro AssignTarget(target, v) AssignV1T(target, v, z.t)

macro BRANCH(target) { DO_ZAM_PROFILE; pc = target; continue; }

########## Unary Ops ##########

# Direct assignment of an existing value.
assign-op Assign
type V

# The same, but where the assignment target (LHS) is a record field.
assign-op Field-LHS-Assign
op1-read
type F

unary-expr-op Clone
no-const
op-type X
set-type $$
set-type2 $1
eval	auto v = $1.ToVal(z.t2)->Clone();
	AssignV1(BuildVal(v, z.t))

unary-expr-op Size
no-const
op-type I U D A N S T V *
explicit-result-type
set-type $$
set-type2 $1
eval-type I	$$ = ZVal(zeek_int_t($1 < 0 ? -$1 : $1));
eval-type U	$$ = ZVal($1);
eval-type D	$$ = ZVal($1 < 0 ? -$1 : $1);
eval-type A	$$ = ZVal(zeek_uint_t($1->AsAddr().GetFamily() == IPv4 ? 32 : 128));
eval-type N	$$ = ZVal(pow(2.0, double(128 - $1->AsSubNet().LengthIPv6())));
eval-type S	$$ = ZVal(zeek_uint_t($1->Len()));
eval-type T	$$ = ZVal(zeek_uint_t($1->Size()));
eval-type V	$$ = ZVal(zeek_uint_t($1->Size()));
eval	auto v = $1.ToVal(z.t2)->SizeVal();
	$$ = BuildVal(v, z.t);

unary-expr-op Not
op-type I
eval ! $1

unary-expr-op Complement
op-type U
eval ~ $1

unary-expr-op Positive
op-type I U D
vector
eval $1

unary-expr-op Negate
op-type I U D
vector
eval -$1

op IncrI
op1-read-write
type V
eval	++$$.int_val;

op IncrU
op1-read-write
type V
eval	++$$.uint_val;

op DecrI
op1-read-write
type V
eval	--$$.int_val;

op DecrU
op1-read-write
type V
eval	auto& u = $$.uint_val;
	if ( u == 0 )
		ZAM_run_time_warning(z.loc, "count underflow");
	--u;

unary-op AppendTo
# Note, even though it feels like appending both reads and modifies
# its first operand, for our purposes it just reads it (to get the
# aggregate), and then modifies its *content* but not the operand's
# value itself.
op1-read
set-type $1
eval	auto vv = $1.vector_val;
	if ( vv->Size() == 0 )
		// Use the slightly more expensive Assign(), since it
		// knows how to deal with empty vectors that do not yet
		// have concrete types.
		vv->Assign(0, $2.ToVal(z.t));
	else
		{
		vv->RawVec().push_back(CopyVal($2));
		vv->Modified();
		}

# For vectors-of-any, we always go through the Assign() interface because
# it's needed for tracking the potentially differing types.
unary-op AppendToAnyVec
op1-read
set-type $1
eval	auto vv = $1.vector_val;
	vv->Assign(vv->Size(), $2.ToVal(z.t));

internal-op AddPatternToField
type VVi
op1-read
eval	EvalAddPatternToField($$.record_val, $1, $2)

macro EvalAddPatternToField(r, v, f)
	auto fpat = r->GetField(z.f)->AsPatternVal();
	if ( fpat )
		{
		v.re_val->AddTo(fpat, false);
		r->Modified();
		}
	else
		ZAM_run_time_error(z.loc, util::fmt("field value missing: $%s", r->GetType()->AsRecordType()->FieldName(z.f)));

internal-op AddPatternToField
type VCi
op1-read
eval	EvalAddPatternToField($$.record_val, $1, $2)

unary-op ExtendPattern
op1-read
eval	$1.re_val->AddTo($$.re_val, false);

unary-op AddVecToVec
op1-read
eval	if ( ! $1.vector_val->AddTo($$.vector_val, false) )
		ZAM_run_time_error(z.loc, "incompatible vector element assignment");

unary-op AddTableToTable
op1-read
eval	auto t = $$.table_val;
	auto v = $1.table_val;
	if ( v->Size() > 0 )
		{
		v->AddTo(t, false);
		t->Modified();
		}

unary-op RemoveTableFromTable
op1-read
eval	auto t = $$.table_val;
	auto v = $1.table_val;
	if ( v->Size() > 0 )
		{
		v->RemoveFrom(t);
		t->Modified();
		}

unary-expr-op Cast
op-type X
set-type $$
set-type2 $1
eval	EvalCast($$, $1.ToVal(z.t2))

macro EvalCast(lhs, rhs)
	std::string error;
	auto res = cast_value(rhs, z.t, error);
	if ( res )
		AssignV1T(lhs, BuildVal(res, z.t), z.t)
	else
		ZAM_run_time_error(z.loc, error.c_str());

# Cast an "any" type to the given type.  Only needed for type-based switch
# statements.
internal-op Cast-Any
type VV
eval	ValPtr rhs = {NewRef{}, $1.any_val};
	EvalCast($$, rhs)

direct-unary-op Is Is

internal-op Is
type VV
eval	auto rhs = $1.ToVal(z.t2).get();
	$$.int_val = can_cast_value_to_type(rhs, z.t.get());

########## Binary Ops ##########

binary-expr-op Add
op-type I U D S
vector
eval $1 + $2
eval-type S	vector<const String*> strings;
		strings.push_back($1->AsString());
		strings.push_back($2->AsString());
		auto res = new StringVal(concatenate(strings));
		$$ = res;

binary-expr-op Sub
op-type I U D T
vector
eval $1 - $2
#
eval-type T	auto v = $1->Clone();
		auto s = v.release()->AsTableVal();
		$2->RemoveFrom(s);
		$$ = s;

binary-expr-op Times
op-type I U D
vector
eval $1 * $2

binary-expr-op Divide
op-type I U D
vector
#
eval-pre	if ( $2 == 0 )
			{
			ZAM_run_time_error(z.loc, "division by zero");
			break;
			}
eval $1 / $2

binary-expr-op Mask
op-type I
vector
### Note that this first "eval" is a dummy - we'll never generate code
### that uses it because "Mask" expressions don't have LHS operands of
### type "int". We could omit this if we modified Gen-ZAM to understand
### that an op-type of 'X' for a binary-expr-op means "skip the usual case
### of two operands of the same type".
eval $1 / $2
eval-mixed A I	auto mask = static_cast<uint32_t>($2);
		auto a = $1->AsAddr();
		if ( a.GetFamily() == IPv4 && mask > 32 )
			ZAM_run_time_error(z.loc, util::fmt("bad IPv4 subnet prefix length: %" PRIu32, mask));
		if ( a.GetFamily() == IPv6 && mask > 128 )
			ZAM_run_time_error(z.loc, util::fmt("bad IPv6 subnet prefix length: %" PRIu32, mask));
		auto v = make_intrusive<SubNetVal>(a, mask);
		Unref($$.subnet_val);
		$$.subnet_val = v.release();

binary-expr-op Mod
op-type I U
vector
eval-pre	if ( $2 == 0 )
			{
			ZAM_run_time_error(z.loc, "modulo by zero");
			break;
			}
eval $1 % $2

binary-expr-op And-And
op-type I
vector
eval zeek_int_t($1 && $2)

binary-expr-op Or-Or
op-type I
vector
eval zeek_int_t($1 || $2)

binary-expr-op And
op-type U P T
vector
eval $1 & $2
#
eval-type P	$$ = new PatternVal(RE_Matcher_conjunction($1->AsPattern(), $2->AsPattern()));
#
eval-type T	$$ = $1->Intersection(*$2).release();

binary-expr-op Or
op-type U P T
vector
eval $1 | $2
#
eval-type P	$$ = new PatternVal(RE_Matcher_disjunction($1->AsPattern(), $2->AsPattern()));
#
eval-type T	auto v = $1->Clone();
		auto s = v.release()->AsTableVal();
		(void) $2->AddTo(s, false, false);
		$$ = s;

binary-expr-op Xor
op-type U
vector
eval $1 ^ $2

binary-expr-op Lshift
op-type I U
vector
eval-type I	if ( $1 < 0 )
			ZAM_run_time_error(z.loc, "left shifting a negative number is undefined");
		$$ = $1 << $2;
eval $1 << $2

binary-expr-op Rshift
op-type I U
vector
eval $1 >> $2

########## Relationals ##########

rel-expr-op LT
op-type I U D S T A
vector
eval $1 < $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) < 0
eval-type T	$1->IsSubsetOf(*$2) && $1->Size() < $2->Size()
eval-type A	$1->AsAddr() < $2->AsAddr()

rel-expr-op LE
op-type I U D S T A
vector
eval $1 <= $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) <= 0
eval-type T	$1->IsSubsetOf(*$2)
eval-type A	$1->AsAddr() < $2->AsAddr() || $1->AsAddr() == $2->AsAddr()

rel-expr-op EQ
op-type I U D S T A N F
vector
eval $1 == $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) == 0
eval-type T	$1->EqualTo(*$2)
eval-type A	$1->AsAddr() == $2->AsAddr()
eval-type N	$1->AsSubNet() == $2->AsSubNet()
eval-type F	util::streq($1->Name(), $2->Name())
eval-mixed P S	$1->MatchExactly($2->AsString())

rel-expr-op NE
op-type I U D S T A N F
vector
eval $1 != $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) != 0
eval-type T	! $1->EqualTo(*$2)
eval-type A	$1->AsAddr() != $2->AsAddr()
eval-type N	$1->AsSubNet() != $2->AsSubNet()
eval-type F	! util::streq($1->Name(), $2->Name())
eval-mixed P S	! $1->MatchExactly($2->AsString())

# Note, canonicalization means that GE and GT shouldn't occur
# for Sets (type T).
rel-expr-op GE
op-type I U D S A
vector
eval $1 >= $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) >= 0
eval-type A	! ($1->AsAddr() < $2->AsAddr())

rel-expr-op GT
op-type I U D S A
vector
eval $1 > $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) > 0
eval-type A	! ($1->AsAddr() < $2->AsAddr()) && $1->AsAddr() != $2->AsAddr()

########## Nonuniform Expressions ##########

assign-op Field
type R
field-op
assign-val v
eval	auto r = frame[z.v2].record_val;
	auto& rv = r->RawOptField(z.v3);
	if ( ! rv )
		{
		auto def = r->GetType<RecordType>()->FieldDefault(z.v3);
		if ( def )
			rv = ZVal(def, z.t);
		else
			{
			ZAM_run_time_error(z.loc, util::fmt("field value missing: $%s", r->GetType()->AsRecordType()->FieldName(z.v3)));
			break;
			}
		}
	auto v = *rv;

expr-op Has-Field
type VRi
includes-field-op
eval	$$.int_val = $1.record_val->HasField($2);

internal-op Has-Field-Cond
op1-read
type VVi
eval	if ( ! $1.record_val->HasField($2) )
		BRANCH($3)

internal-op Not-Has-Field-Cond
op1-read
type VVi
eval	if ( $1.record_val->HasField($2) )
		BRANCH($3)

internal-op Table-Has-Elements
type VV
eval	$$.int_val = $1.table_val->Size() > 0;

internal-op Table-Has-Elements-Cond
op1-read
type Vi
eval	if ( $1.table_val->Size() == 0 )
		BRANCH($2)

internal-op Not-Table-Has-Elements-Cond
op1-read
type Vi
eval	if ( $1.table_val->Size() > 0 )
		BRANCH($2)

internal-op Vector-Has-Elements
type VV
eval	$$.int_val = $1.vector_val->Size() > 0;

internal-op Vector-Has-Elements-Cond
op1-read
type Vi
eval	if ( $1.vector_val->Size() == 0 )
		BRANCH($2)

internal-op Not-Vector-Has-Elements-Cond
op1-read
type Vi
eval	if ( $1.vector_val->Size() > 0 )
		BRANCH($2)

expr-op In
type VVV
custom-method return CompileInExpr(n1, n2, n3);
no-eval

expr-op In
type VCV
custom-method return CompileInExpr(n1, c, n2);
no-eval

expr-op In
type VVC
custom-method return CompileInExpr(n1, n2, c);
no-eval

macro EvalPInS(lhs, op1, op2)
	lhs.int_val = op1.re_val->MatchAnywhere(op2.string_val->AsString()) != 0;

internal-op P-In-S
type VVV
eval	EvalPInS($$, $1, $2)

internal-op P-In-S
type VCV
eval	EvalPInS($$, $1, $2)

internal-op P-In-S
type VVC
eval	EvalPInS($$, $1, $2)

macro EvalStrInPatTbl(lhs, op1, op2)
	lhs.int_val = op2.table_val->MatchPattern({NewRef{}, op1.string_val});

internal-op Str-In-Pat-Tbl
type VVV
eval	EvalStrInPatTbl($$, $1, $2)

internal-op Str-In-Pat-Tbl
type VCV
eval	EvalStrInPatTbl($$, $1, $2)

internal-binary-op S-In-S
op-accessor string_val
op-type I
eval	auto sc = reinterpret_cast<const unsigned char*>(op1->CheckString());
	auto cmp = util::strstr_n(op2->Len(), op2->Bytes(), op1->Len(), sc);
	$$ = cmp != -1;

internal-binary-op A-In-S
op1-accessor addr_val
op2-accessor subnet_val
op-type I
eval	$$ = op2->Contains(op1->AsAddr());


# Handled differently because of the unusual middle argument.
op L-In-T
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-T
type VLC
custom-method return CompileInExpr(n, l, c);
no-eval

op L-In-Vec
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-Vec
type VLC
custom-method return CompileInExpr(n, l, c);
no-eval


internal-op Val-Is-In-Table
type VVV
# No set-type as these are internal ops.
eval	auto op1 = $1.ToVal(z.t);
	$$.int_val = $2.table_val->Find(op1) != nullptr;

internal-op Val-Is-In-Table-Cond
op1-read
type VVi
eval	auto op1 = $1.ToVal(z.t);
	if ( ! $2.table_val->Find(op1) )
		BRANCH($3)

internal-op Val-Is-Not-In-Table-Cond
op1-read
type VVi
eval	auto op1 = $1.ToVal(z.t);
	if ( $2.table_val->Find(op1) )
		BRANCH($3)

# Variants for indexing two values, one of which might be a constant.
# We set the instructions's *second* type to be that of the first variable
# index.  We get the type of the second variable (if any) by digging it
# out of the table's type.  For a constant in either position, we use
# the main instruction type, as always.

macro EvalVal2InTableCore(op1, op2)
	auto lvp = zeek::make_intrusive<ListVal>(TYPE_ANY);
	lvp->Append(op1);
	lvp->Append(op2);

macro EvalVal2InTableAssignCore(lhs, tbl)
	lhs.int_val = tbl.table_val->Find(std::move(lvp)) != nullptr;

macro EvalVal2InTablePre(op1, op2, tbl)
	auto& tt_ind = tbl.table_val->GetType()->AsTableType()->GetIndexTypes();
	EvalVal2InTableCore(op1.ToVal(z.t2), op2.ToVal(tt_ind[1]))

internal-op Val2-Is-In-Table
type VVVV
eval	EvalVal2InTablePre($1,$2,$3)
	EvalVal2InTableAssignCore($$, $3)

internal-op Val2-Is-In-Table-Cond
op1-read
type VVVi
eval	EvalVal2InTablePre($1,$2,$3)
	EvalVal2InTableCond($3, lvp, $4, !)

macro EvalVal2InTableCond(tbl, op, target, negate)
	if ( negate tbl.table_val->Find(op) )
		BRANCH(target)

internal-op Val2-Is-Not-In-Table-Cond
op1-read
type VVVi
eval	EvalVal2InTablePre($1,$2,$3)
	EvalVal2InTableCond($3, lvp, $4,)

internal-op Val2-Is-In-Table
type VVVC
eval	EvalVal2InTableCore($1.ToVal(z.t2), $3.ToVal(z.t))
	EvalVal2InTableAssignCore($$, $2)

internal-op Val2-Is-In-Table-Cond
op1-read
type VViC
eval	EvalVal2InTableCore($1.ToVal(z.t2), $4.ToVal(z.t))
	EvalVal2InTableCond($2, lvp, $3, !)

internal-op Val2-Is-Not-In-Table-Cond
op1-read
type VViC
eval	EvalVal2InTableCore($1.ToVal(z.t2), $4.ToVal(z.t))
	EvalVal2InTableCond($2, lvp, $3, )

internal-op Val2-Is-In-Table
type VVCV
eval	EvalVal2InTableCore($2.ToVal(z.t), $1.ToVal(z.t2))
	EvalVal2InTableAssignCore($$, $3)

internal-op Val2-Is-In-Table-Cond
op1-read
type VVCi
eval	EvalVal2InTableCore($3.ToVal(z.t), $1.ToVal(z.t2))
	EvalVal2InTableCond($2, lvp, $4, !)

internal-op Val2-Is-Not-In-Table-Cond
op1-read
type VVCV
eval	EvalVal2InTableCore($3.ToVal(z.t), $1.ToVal(z.t2))
	EvalVal2InTableCond($2, lvp, $4, )


internal-op Const-Is-In-Table
type VCV
eval	auto op1 = $1.ToVal(z.t);
	$$.int_val = $2.table_val->Find(op1) != nullptr;

internal-op Const-Is-In-Table-Cond
op1-read
type ViC
eval	auto op1 = $3.ToVal(z.t);
	if ( ! $1.table_val->Find(op1) )
		BRANCH($2)

internal-op Const-Is-Not-In-Table-Cond
op1-read
type ViC
eval	auto op1 = $3.ToVal(z.t);
	if ( $1.table_val->Find(op1) )
		BRANCH($2)

internal-op List-Is-In-Table
type VV
eval	auto op1 = z.aux->ToListVal(frame);
	$$.int_val = $1.table_val->Find(std::move(op1)) != nullptr;

internal-op List-Is-In-Table
type VC
eval	auto op1 = z.aux->ToListVal(frame);
	$$.int_val = $1.table_val->Find(std::move(op1)) != nullptr;

internal-op Val-Is-In-Vector
type VVV
eval	auto& vec = $2.vector_val;
	auto ind = $1.int_val;
	$$.int_val = vec->Has(ind);

internal-op Const-Is-In-Vector
type VCV
eval	auto& vec = $2.vector_val;
	auto ind = $1.int_val;
	$$.int_val = vec->Has(ind);

expr-op Cond
type VVVV
set-type $2
eval	AssignTarget($$, $1.int_val ? CopyVal($2) : CopyVal($3))

expr-op Cond
type VVVC
set-type $2
eval	AssignTarget($$, $1.int_val ? CopyVal($2) : CopyVal($3))

expr-op Cond
type VVCV
set-type $2
eval	AssignTarget($$, $1.int_val ? CopyVal($2) : CopyVal($3))

op Bool-Vec-Cond
type VVVV
set-type $2
eval	auto& vsel = $1.vector_val->RawVec();
	auto& v1 = $2.vector_val->RawVec();
	auto& v2 = $3.vector_val->RawVec();
	auto n = v1.size();
	auto res = new vector<std::optional<ZVal>>(n);
	for ( auto i = 0U; i < n; ++i )
		if ( vsel[i] )
			(*res)[i] = vsel[i]->int_val ? v1[i] : v2[i];
	auto& full_res = $$.vector_val;
	Unref(full_res);
	full_res = new VectorVal(cast_intrusive<VectorType>(z.t), res);

# Our instruction format doesn't accommodate two constants, so for
# the singular case of a V ? C1 : C2 conditional, we split it into
# two operations, V ? C1 and !V ? C2.
op CondC1
type VVC
set-type $$
eval	if ( $1.int_val )
		AssignTarget($$, CopyVal($2))

op CondC2
set-type $$
type VVC
eval	if ( ! $1.int_val )
		AssignTarget($$, CopyVal($2))

########## Index Expressions ##########

op IndexVecBoolSelect
type VVV
set-type $$
eval	EvalIndexVecBoolSelect($$, $1, $2)

macro EvalIndexVecBoolSelect(lhs, op1, op2)
	if ( op1.vector_val->Size() != op2.vector_val->Size() )
		{
		ZAM_run_time_error(z.loc, "size mismatch, boolean index and vector");
		break;
		}
	auto vt = cast_intrusive<VectorType>(z.t);
	auto v2 = op1.vector_val;
	auto v3 = op2.vector_val;
	auto v = vector_bool_select(std::move(vt), v2, v3);
	Unref(lhs.vector_val);
	lhs.vector_val = v.release();

op IndexVecBoolSelect
type VCV
set-type $$
eval	EvalIndexVecBoolSelect($$, $1, $2)

op IndexVecIntSelect
type VVV
set-type $$
eval	EvalIndexVecIntSelect($$, $1, $2)

macro EvalIndexVecIntSelect(lhs, op1, op2)
	auto vt = cast_intrusive<VectorType>(z.t);
	auto v2 = op1.vector_val;
	auto v3 = op2.vector_val;
	auto v = vector_int_select(std::move(vt), v2, v3);
	Unref(lhs.vector_val);
	lhs.vector_val = v.release();

op IndexVecIntSelect
type VCV
set-type $$
eval	EvalIndexVecIntSelect($$, $1, $2)

op Index
type VVL
custom-method return CompileIndex(n1, n2, l, false);
no-eval

op Index
type VCL
custom-method return CompileIndex(n, c, l, false);
no-eval

op WhenIndex
type VVL
custom-method return CompileIndex(n1, n2, l, true);
no-eval

op WhenIndex
type VCL
custom-method return CompileIndex(n, c, l, true);
no-eval

internal-op Index-Vec
type VVV
eval	EvalIndexVec($$, $1, $2)

macro EvalIndexVec(lhs, vec, index)
	auto& vv = vec.vector_val->RawVec();
	const auto& vec = vv;
	zeek_int_t ind = index;
	if ( ind < 0 )
		ind += vv.size();
	if ( ind < 0 || ind >= int(vv.size()) )
		ZAM_run_time_error(z.loc, "no such index");
	AssignTarget(lhs, CopyVal(*vec[ind]))

internal-op Index-VecC
type VVi
eval	EvalIndexVec($$, $1, $2)

internal-op Index-Any-Vec
type VVV
eval	EvalIndexAnyVec($$, $1, $2.uint_val)

macro EvalIndexAnyVec(lhs, vec, index)
	auto vv = vec.vector_val;
	zeek_int_t ind = index;
	if ( ind < 0 )
		ind += vv->Size();
	if ( ind < 0 || ind >= int(vv->Size()) )
		ZAM_run_time_error(z.loc, "no such index");
	AssignTarget(lhs, ZVal(vv->ValAt(ind).release()))

internal-op Index-Any-VecC
type VVi
eval	EvalIndexAnyVec($$, $1, $2)

macro	WhenIndexResCheck(vec)
	auto& res = vec.vector_val;
	if ( res && IndexExprWhen::evaluating > 0 )
		IndexExprWhen::results.push_back({NewRef{}, res});

internal-op When-Index-Vec
type VVV
eval	EvalIndexAnyVec($$, $1, $2.uint_val)
	WhenIndexResCheck($$)

internal-op When-Index-VecC
type VVi
eval	EvalIndexAnyVec($$, $1, $2)
	WhenIndexResCheck($$)

macro	EvalVecSlice(lhs, vv)
	auto vec = vv.vector_val;
	auto lv = z.aux->ToListVal(frame);
	auto v = index_slice(vec, lv.get());
	Unref(lhs.vector_val);
	lhs.vector_val = v.release();

internal-op Index-Vec-Slice
type VV
eval	EvalVecSlice($$, $1)

internal-op When-Index-Vec-Slice
type VV
eval	EvalVecSlice($$, $1)
	WhenIndexResCheck($$)

internal-op Table-Index
type VV
eval	EvalTableIndex($1, z.aux->ToListVal(frame))
	AssignTarget($$, BuildVal(v, z.t))

macro	EvalTablePatStr(lhs, tbl, index)
	auto vec = ZVal(tbl.table_val->LookupPattern({NewRef{}, index.string_val}));
	ZVal::DeleteManagedType(lhs);
	lhs = vec;

internal-op Table-PatStr-Index
type VVV
eval	EvalTablePatStr($$, $1, $2)

internal-op Table-PatStr-Index
type VVC
eval	EvalTablePatStr($$, $1, $2)

internal-op When-Table-Index
type VV
eval	EvalTableIndex($1, z.aux->ToListVal(frame))
	if ( IndexExprWhen::evaluating > 0 )
		IndexExprWhen::results.emplace_back(v);
	AssignTarget($$, BuildVal(v, z.t))

macro EvalTableIndex(tbl, index)
	auto v = tbl.table_val->FindOrDefault(index);
	if ( ! v )
		{
		ZAM_run_time_error(z.loc, "no such index");
		break;
		}

internal-op When-PatStr-Index
type VV
eval	auto args = z.aux->ToListVal(frame);
	auto arg0 = args->Idx(0);
	auto v = $1.table_val->LookupPattern({NewRef{}, arg0->AsStringVal()});
	if ( IndexExprWhen::evaluating > 0 )
		IndexExprWhen::results.emplace_back(v);
	AssignTarget($$, BuildVal(v, z.t))

internal-assignment-op Table-Index1
type VVV
assign-val v
eval	EvalTableIndex(frame[z.v3].ToVal(z.t))
# No AssignV1 needed, as this is an assignment-op

internal-assignment-op Table-Index1
type VVC
assign-val v
eval	EvalTableIndex(z.c.ToVal(z.t))

# This version is for a variable v3.
internal-op Index-String
type VVV
eval	EvalIndexString($$, $1, $2.int_val)

macro EvalIndexString(lhs, s, index)
	auto str = s.string_val->AsString();
	auto len = str->Len();
	auto idx = index;
	if ( idx < 0 )
		idx += len;
	auto v = str->GetSubstring(idx, 1);
	Unref(lhs.string_val);
	lhs.string_val = new StringVal(v ? v : new String(""));

# This version is for a constant v3.
internal-op Index-StringC
type VVi
eval	EvalIndexString($$, $1, $2)

internal-op Index-String-Slice
type VV
eval	auto str = $1.string_val->AsString();
	auto lv = z.aux->ToListVal(frame);
	auto slice = index_string(str, lv.get());
	Unref($$.string_val);
	$$.string_val = new StringVal(slice->ToStdString());

op AnyIndex
type VVi
set-type $$
eval	auto lv = $1.any_val->AsListVal();
	if ( $2 < 0 || $2 >= lv->Length() )
		reporter->InternalError("bad \"any\" element index");
	ValPtr elem = lv->Idx($2);
	if ( CheckAnyType(elem->GetType(), z.t, z.loc) )
		AssignTarget($$, BuildVal(elem, z.t))
	else
		ZAM_error = true;


########## Constructors ##########

# Table construction requires atypical evaluation of list elements
# using information from their expression specifics.
direct-unary-op Table-Constructor ConstructTable

macro ConstructTableOrSetPre()
	auto tt = cast_intrusive<TableType>(z.t);
	auto new_t = new TableVal(tt, z.aux->attrs);
	auto aux = z.aux;
	auto n = aux->n;
	auto ind_width = z.v2;

macro ConstructTableOrSetPost(lhs)
	auto& t = lhs.table_val;
	Unref(t);
	t = new_t;

internal-op Construct-Table
type V
eval	ConstructTableOrSetPre()
	for ( auto i = 0; i < n; ++i )
		{
		auto indices = aux->ToIndices(frame, i, ind_width);
		auto v = aux->ToVal(frame, i + ind_width);
		new_t->Assign(indices, v);
		i += ind_width;
		}
	ConstructTableOrSetPost($$)

# When tables are constructed, if their &default is a lambda with captures
# then we need to explicitly set up the default.
internal-op Set-Table-Default-Lambda
type VV
op1-read
eval	auto& tbl = $1.table_val;
	auto lambda = $2.ToVal(z.t);
	tbl->InitDefaultVal(std::move(lambda));

direct-unary-op Set-Constructor ConstructSet

internal-op Construct-Set
type V
eval	ConstructTableOrSetPre()
	for ( auto i = 0; i < n; i += ind_width )
		{
		auto indices = aux->ToIndices(frame, i, ind_width);
		new_t->Assign(indices, nullptr);
		}
	ConstructTableOrSetPost($$)

direct-unary-op Record-Constructor ConstructRecord

macro ConstructRecordPost(lhs)
	auto& r = lhs.record_val;
	Unref(r);
	r = new RecordVal(cast_intrusive<RecordType>(z.t), std::move(init_vals));

op Construct-Direct-Record
type V
eval	auto init_vals = z.aux->ToZValVec(frame);
	ConstructRecordPost($$)

op Construct-Known-Record
type V
eval	auto init_vals = z.aux->ToZValVecWithMap(frame);
	ConstructRecordPost($$)

op Construct-Known-Record-With-NT
type Vi
eval	auto init_vals = z.aux->ToZValVecWithMap(frame);
	ASSERT(! init_vals[$1]);
	init_vals[$1] = ZVal(run_state::network_time);
	ConstructRecordPost($$)

op Construct-Known-Record-With-Inits
type V
eval	auto init_vals = z.aux->ToZValVecWithMap(frame);
	for ( auto& fi : *z.aux->field_inits )
		init_vals[fi.first] = fi.second->Generate();
	ConstructRecordPost($$)

op Construct-Known-Record-With-Inits-And-NT
type Vi
eval	auto init_vals = z.aux->ToZValVecWithMap(frame);
	for ( auto& fi : *z.aux->field_inits )
		init_vals[fi.first] = fi.second->Generate();
	ASSERT(! init_vals[$1]);
	init_vals[$1] = ZVal(run_state::network_time);
	ConstructRecordPost($$)

# Special instruction for concretizing vectors that are fields in a
# newly-constructed record. "aux" holds which fields in the record to
# inspect.
op Concretize-Vector-Fields
op1-read
type V
eval	auto rt = cast_intrusive<RecordType>(z.t);
	auto r = $1.record_val;
	auto aux = z.aux;
	auto n = aux->n;
	for ( auto i = 0; i < n; ++i )
		{
		auto ind = aux->elems[i].IntVal();
		auto v_i = r->GetField(ind);
		ASSERT(v_i);
		if ( v_i->GetType<VectorType>()->IsUnspecifiedVector() )
			{
			const auto& t_i = rt->GetFieldType(ind);
			v_i->AsVectorVal()->Concretize(t_i->Yield());
			}
		}

direct-unary-op Vector-Constructor ConstructVector

internal-op Construct-Vector
type V
eval	auto new_vv = new VectorVal(cast_intrusive<VectorType>(z.t));
	auto aux = z.aux;
	auto n = aux->n;
	for ( auto i = 0; i < n; ++i )
		new_vv->Assign(i, aux->ToVal(frame, i));
	auto& vv = $$.vector_val;
	Unref(vv);
	vv = new_vv;

########## Coercions ##########

direct-unary-op Arith-Coerce ArithCoerce

internal-op Coerce-UI
type VV
eval	auto v = $1.int_val;
	if ( v < 0 )
		{
		ZAM_run_time_error(z.loc, "underflow converting int to count");
		break;
		}
	$$.uint_val = zeek_uint_t(v);

internal-op Coerce-UD
type VV
eval	auto v = $1.double_val;
	if ( v < 0.0 )
		{
		ZAM_run_time_error(z.loc, "underflow converting double to count");
		break;
		}
	if ( v > static_cast<double>(UINT64_MAX) )
		{
		ZAM_run_time_error(z.loc, "overflow converting double to count");
		break;
		}
	$$.uint_val = zeek_uint_t(v);

internal-op Coerce-IU
type VV
eval	auto v = $1.uint_val;
	if ( v > INT64_MAX )
		{
		ZAM_run_time_error(z.loc, "overflow converting count to int");
		break;
		}
	$$.int_val = zeek_int_t(v);

internal-op Coerce-ID
type VV
eval	auto v = $1.double_val;
	if ( v < static_cast<double>(INT64_MIN) )
		{
		ZAM_run_time_error(z.loc, "underflow converting double to int");
		break;
		}
	if ( v > static_cast<double>(INT64_MAX) )
		{
		ZAM_run_time_error(z.loc, "overflow converting double to int");
		break;
		}
	$$.int_val = zeek_int_t(v);

internal-op Coerce-DI
type VV
eval	$$.double_val = double($1.int_val);

internal-op Coerce-DU
type VV
eval	$$.double_val = double($1.uint_val);


macro EvalCoerceVec(lhs, rhs, coercer)
	auto old_v1 = lhs.vector_val;
	lhs.vector_val = coercer(rhs.vector_val, z);
	Unref(old_v1);	// delayed to allow for same value on both sides

internal-op Coerce-UI-Vec
type VV
eval	EvalCoerceVec($$, $1, vec_coerce_UI)

internal-op Coerce-UD-Vec
type VV
eval	EvalCoerceVec($$, $1, vec_coerce_UD)

internal-op Coerce-IU-Vec
type VV
eval	EvalCoerceVec($$, $1, vec_coerce_IU)

internal-op Coerce-ID-Vec
type VV
eval	EvalCoerceVec($$, $1, vec_coerce_ID)

internal-op Coerce-DI-Vec
type VV
eval	EvalCoerceVec($$, $1, vec_coerce_DI)

internal-op Coerce-DU-Vec
type VV
eval	EvalCoerceVec($$, $1, vec_coerce_DU)


direct-unary-op Record-Coerce RecordCoerce

internal-op Record-Coerce
type VV
eval	auto rt = cast_intrusive<RecordType>(z.t);
	auto v = $1.record_val;
	auto to_r = coerce_to_record(std::move(rt), v, z.aux->map);
	Unref($$.record_val);
	$$.record_val = to_r.release();

direct-unary-op Table-Coerce TableCoerce

internal-op Table-Coerce
type VV
eval	auto tv = $1.table_val;
	if ( tv->Size() > 0 )
		{
		ZAM_run_time_error(z.loc, "coercion of non-empty table/set");
		break;
		}
	auto tt = cast_intrusive<TableType>(z.t);
	AttributesPtr attrs = tv->GetAttrs();
	auto t = make_intrusive<TableVal>(tt, attrs);
	Unref($$.table_val);
	$$.table_val = t.release();

direct-unary-op Vector-Coerce VectorCoerce

internal-op Vector-Coerce
type VV
eval	if ( $1.vector_val->Size() > 0 )
		{
		ZAM_run_time_error(z.loc, "coercion of non-empty vector");
		break;
		}
	auto vv = new VectorVal(cast_intrusive<VectorType>(z.t));
	Unref($$.vector_val);
	$$.vector_val = vv;

unary-expr-op To-Any-Coerce
op-type X
set-type $1
eval	AssignTarget($$, ZVal($1.ToVal(z.t), ZAM::any_base_type))

unary-expr-op From-Any-Coerce
op-type X
set-type $$
eval	auto v = $1.any_val;
	AssignTarget($$, ZVal({NewRef{}, v}, z.t))

unary-expr-op From-Any-Vec-Coerce
op-type X
set-type $$
eval	auto vv = $1.vector_val;
	if ( ! vv->Concretize(z.t->Yield()) )
		{
		ZAM_run_time_error(z.loc, "incompatible vector-of-any");
		break;
		}
	zeek::Ref(vv);
	AssignTarget($$, ZVal(vv))


########## Aggregate Assignments ##########

macro VectorElemAssignPre(vec, index)
	auto ind = index.uint_val;
	auto vv = vec.vector_val;

macro EvalVectorElemAssign(vec, index, val_setup, assign_op)
	VectorElemAssignPre(vec, index)
	val_setup
	if ( ! assign_op )
		ZAM_run_time_error(z.loc, "value used but not set");

op Vector-Elem-Assign
op1-read
set-type $1
type VVV
eval	EvalVectorElemAssign($1, $2,, copy_vec_elem(vv, ind, $3, z.t))

op Any-Vector-Elem-Assign
op1-read
set-type $1
type VVV
eval	EvalVectorElemAssign($1, $2,, vv->Assign(ind, $3.ToVal(z.t)))

op Vector-Elem-Assign-Any
op1-read
type VVV
eval	EvalVectorElemAssign($1, $2, auto any_v = $3.any_val;, vv->Assign(ind, {NewRef{}, any_v}))

op Vector-Elem-Assign
op1-read
set-type $2
type VVC
eval	VectorElemAssignPre($1, $2)
	(void) copy_vec_elem(vv, ind, $3, z.t);

op Any-Vector-Elem-Assign
op1-read
set-type $1
type VVC
eval	VectorElemAssignPre($1, $2)
	if ( ! vv->Assign(ind, $3.ToVal(z.t)) )
		ZAM_run_time_error(z.loc, "vector index assignment failed for invalid type");

# These versions are used when the constant is the index, not the new value.
op Vector-Elem-Assign
op1-read
set-type $1
type VVi
eval	auto vv = $1.vector_val;
	if ( ! copy_vec_elem(vv, $3, $2, z.t) )
		ZAM_run_time_error(z.loc, "value used but not set");

op Any-Vector-Elem-Assign
op1-read
set-type $1
type VVi
eval	auto vv = $1.vector_val;
	if ( ! vv->Assign($3, $2.ToVal(z.t)) )
		ZAM_run_time_error(z.loc, "value used but not set");

op Vector-Elem-Assign-Any
op1-read
type VVi
eval	auto vv = $1.vector_val;
	auto any_v = $2.any_val;
	vv->Assign($3, {NewRef{}, any_v});

internal-op Vector-Slice-Assign
op1-read
type VV
eval	ValPtr vec = {NewRef{}, $1.vector_val};
	auto slice = z.aux->ToListVal(frame);
	ValPtr vals = {NewRef{}, $2.vector_val};
	bool iterators_invalidated;
	auto error = assign_to_index(std::move(vec), std::move(slice), std::move(vals), iterators_invalidated);
	if ( error )
		ZAM_run_time_error(z.loc, error);
	if ( iterators_invalidated )
		ZAM_run_time_warning(z.loc, "possible loop/iterator invalidation");


internal-op Table-Elem-Assign
op1-read
type VV
eval	EvalTableElemAssign($1, $2)

macro EvalTableElemAssign(tbl, value)
	auto indices = z.aux->ToListVal(frame);
	auto val = value.ToVal(z.t);
	bool iterators_invalidated = false;
	tbl.table_val->Assign(std::move(indices), std::move(val), true, &iterators_invalidated);
	if ( iterators_invalidated )
		ZAM_run_time_warning(z.loc, "possible loop/iterator invalidation");

internal-op Table-Elem-Assign
op1-read
type VC
eval	EvalTableElemAssign($1, $2)


########## Function Calls ##########

# A call with no arguments and no return value.
internal-op Call0
op1-read
type X
side-effects
num-call-args 0

# A call with no arguments and a return value.
internal-assignment-op Call0
type V
side-effects OP_CALL0_X OP_X
assign-val v
num-call-args 0

# Calls with 1 argument and no return value.
internal-op Call1
op1-read
type V
side-effects
num-call-args 1

internal-op Call1
op1-read
type C
side-effects
num-call-args 1

# Same but with a return value.
internal-assignment-op Call1
type VV
side-effects OP_CALL1_V OP_V
assign-val v
num-call-args 1

internal-assignment-op Call1
type VC
side-effects OP_CALL1_C OP_C
assign-val v
num-call-args 1

# Calls with 2-5 arguments and no return value.
internal-op Call2
type X
side-effects
num-call-args 2

# Same with a return value.
internal-assignment-op Call2
type V
side-effects OP_CALL2_X OP_X
assign-val v
num-call-args 2

internal-op Call3
type X
side-effects
num-call-args 3

# Same with a return value.
internal-assignment-op Call3
type V
side-effects OP_CALL3_X OP_X
assign-val v
num-call-args 3

internal-op Call4
type X
side-effects
num-call-args 4

# Same with a return value.
internal-assignment-op Call4
type V
side-effects OP_CALL4_X OP_X
assign-val v
num-call-args 4

internal-op Call5
type X
side-effects
num-call-args 5

# Same with a return value.
internal-assignment-op Call5
type V
side-effects OP_CALL5_X OP_X
assign-val v
num-call-args 5

# ... and with an arbitrary number of arguments.

internal-op CallN
type X
side-effects
num-call-args n

# Same with a return value.
internal-assignment-op CallN
type V
side-effects OP_CALLN_X OP_X
assign-val v
num-call-args n

# Same, but for indirect calls via a global variable.
internal-op IndCallN
type X
side-effects
indirect-call
num-call-args n

# Same with a return value.
internal-assignment-op IndCallN
type V
side-effects OP_INDCALLN_X OP_X
assign-val v
indirect-call
num-call-args n

# And versions with a local variable rather than a global.
internal-op Local-IndCallN
op1-read
type V
side-effects
indirect-local-call
num-call-args n

internal-assignment-op Local-IndCallN
type VV
side-effects OP_LOCAL_INDCALLN_V OP_V
assign-val v
indirect-local-call
num-call-args n

# A call made in a "when" context.  These always have assignment targets.
# To keep things simple, we just use one generic flavor (for N arguments,
# doing a less-streamlined-but-simpler Val-based assignment).
macro WhenCall(lhs, func)
	if ( ! func )
		throw ZAMDelayedCallException();
	auto trigger = f->GetTrigger();
	Val* v = trigger ? trigger->Lookup(z.aux->call_expr.get()) : nullptr;
	ValPtr vp;
	if ( v )
		vp = {NewRef{}, v};
	else
		{
		auto aux = z.aux;
		auto current_assoc = f->GetTriggerAssoc();
		auto n = aux->n;
		std::vector<ValPtr> args;
		for ( auto i = 0; i < n; ++i )
			args.push_back(aux->ToVal(frame, i));
		f->SetCall(z.aux->call_expr.get());
		/* It's possible that this function will call another that
		 * itself returns null because *it* is the actual blocker.
		 * That will set ZAM_error, which we need to ignore.
		 */
		auto hold_ZAM_error = ZAM_error;
		vp = func->Invoke(&args, f);
		ZAM_error = hold_ZAM_error;
		f->SetTriggerAssoc(current_assoc);
		if ( ! vp )
			throw ZAMDelayedCallException();
		}
	if ( z.is_managed )
		ZVal::DeleteManagedType(lhs);
	lhs = ZVal(vp, z.t);

internal-op WhenCallN
type V
side-effects
eval	WhenCall($$, z.aux->func)

internal-op WhenIndCallN
type Vi
side-effects
eval	auto sel = $1;
	auto func = (sel < 0) ? z.aux->id_val->GetVal()->AsFunc() : frame[sel].AsFunc();
	WhenCall($$, func)


########## Statements ##########

macro EvalScheduleArgs(time, is_delta, build_args)
	if ( run_state::terminating )
		break;
	double dt = time.double_val;
	if ( is_delta )
		dt += run_state::network_time;
	auto handler = EventHandlerPtr(z.aux->event_handler);
	ValVec args;
	build_args
	auto timer = new ScheduleTimer(handler, std::move(args), dt);
	timer_mgr->Add(timer);

macro EvalSchedule(time, is_delta)
	EvalScheduleArgs(time, is_delta, z.aux->FillValVec(args, frame);)

op Schedule
type ViHL
op1-read
custom-method return CompileSchedule(n, nullptr, i, h, l);
eval	EvalSchedule($1, $2)

op Schedule
type CiHL
op1-read
custom-method return CompileSchedule(nullptr, c, i, h, l);
eval	EvalSchedule($1, $2)

internal-op Schedule0
type ViH
op1-read
eval	EvalScheduleArgs($1, $2,)

internal-op Schedule0
type CiH
op1-read
eval	EvalScheduleArgs($1, $2,)

macro QueueEvent(eh, args)
	if ( *eh )
		event_mgr.Enqueue(eh, std::move(args));

op Event
type HL
op1-read
custom-method return CompileEvent(h, l);
eval	ValVec args;
	z.aux->FillValVec(args, frame);
	QueueEvent(z.aux->event_handler, args);

internal-op Event0
type X
eval	ValVec args(0);
	QueueEvent(z.aux->event_handler, args);

internal-op Event1
type V
op1-read
eval	ValVec args(1);
	args[0] = $1.ToVal(z.t);
	QueueEvent(z.aux->event_handler, args);

internal-op Event2
type VV
op1-read
eval	ValVec args(2);
	args[0] = $1.ToVal(z.t);
	args[1] = $2.ToVal(z.t2);
	QueueEvent(z.aux->event_handler, args);

internal-op Event3
type VVV
op1-read
eval	ValVec args(3);
	auto& aux = z.aux;
	args[0] = $1.ToVal(z.t);
	args[1] = $2.ToVal(z.t2);
	args[2] = $3.ToVal(aux->elems[2].GetType());
	QueueEvent(z.aux->event_handler, args);

internal-op Event4
type VVVV
op1-read
eval	ValVec args(4);
	auto& aux = z.aux;
	args[0] = $1.ToVal(z.t);
	args[1] = $2.ToVal(z.t2);
	args[2] = $3.ToVal(aux->elems[2].GetType());
	args[3] = $4.ToVal(aux->elems[3].GetType());
	QueueEvent(z.aux->event_handler, args);


op Return
type X
eval	EvalReturn(nullptr,)

macro EvalReturn(val, type)
	ret_u = val;
	type
	DO_ZAM_PROFILE
	pc = end_pc;
	continue;

op Return
op1-read
type V
set-type $$
eval	EvalReturn(&$$, ret_type = z.t;)

op Return
type C
eval	EvalReturn(&$$, ret_type = z.t;)


# Branch on the value of v1 using switch table v2, with default branch to v3

macro EvalSwitchBody(index, branch, cases, postscript)
	{
	auto t = cases[z.v2];
	if ( t.find(v) == t.end() )
		pc = z.v3;
	else
		pc = t[v];
	postscript
	DO_ZAM_PROFILE
	continue;
	}

internal-op SwitchI
type Vii
op1-read
eval	auto v = $1.int_val;
	EvalSwitchBody($2, $3, int_cases,)

internal-op SwitchU
op1-read
type Vii
eval	auto v = $1.uint_val;
	EvalSwitchBody($2, $3, uint_cases,)

internal-op SwitchD
op1-read
type Vii
eval	auto v = $1.double_val;
	EvalSwitchBody($2, $3, double_cases,)

internal-op SwitchS
op1-read
type Vii
eval	auto vs = $1.string_val->AsString()->Render();
	std::string v(vs);
	EvalSwitchBody($2, $3, str_cases,delete[] vs;)

internal-op SwitchA
op1-read
type VVV
eval	auto v = $1.addr_val->AsAddr().AsString();
	EvalSwitchBody($2, $3, str_cases,)

internal-op SwitchN
op1-read
type VVV
eval	auto v = $1.subnet_val->AsSubNet().AsString();
	EvalSwitchBody($2, $3, str_cases,)


internal-op Branch-If-Not-Type
op1-read
type Vi
eval	auto v = $1.any_val;
	if ( ! can_cast_value_to_type(v, z.t.get()) )
		BRANCH($2)


internal-op Init-Table-Loop
type Vi
op1-read
eval	auto& ti = (*tiv_ptr)[$2];
	ti.BeginLoop({NewRef{}, $1.table_val}, z.aux);

internal-op Next-Table-Iter
op1-read
# v1 = iteration info
# v2 = branch target if loop done
type ii
eval	NextTableIterPre($1, $2)
	ti.NextIter(frame);

macro NextTableIterPre(iter, branch)
	auto& ti = (*tiv_ptr)[iter];
	if ( ti.IsDoneIterating() )
		BRANCH(branch)

internal-op Next-Table-Iter-No-Vars
op1-read
# v1 = iteration info
# v2 = branch target if loop done
type VV
eval	NextTableIterPre($1, $2)
	ti.IterFinished();

internal-op Next-Table-Iter-Val-Var
# v1 = slot of the "ValueVar"
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval	NextTableIterPre($1, $2)
	AssignTarget($$, ti.IterValue());
	ti.NextIter(frame);

internal-op Next-Table-Iter-Val-Var-No-Vars
# v1 = slot of the "ValueVar"
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval	NextTableIterPre($1, $2)
	AssignTarget($$, ti.IterValue());
	ti.IterFinished();


internal-op Init-Vector-Loop
type Vi
op1-read
eval	auto& vv = $1.vector_val->RawVec();
	step_iters[$2].InitLoop(&vv);

macro NextVectorIterCore(info, branch)
	auto& si = step_iters[info];
	if ( si.IsDoneIterating() )
		BRANCH(branch)
	const auto& vv = *si.vv;
	if ( ! vv[si.iter] )
		{ /* Account for vector hole.  Re-execute for next position. */
		si.IterFinished();
		--pc;	/* so we then increment to here again */
		break;
		}

internal-op Next-Vector-Iter
# v1 = iteration variable
# v2 = iteration info
# v3 = branch target if loop done
type Vii
eval	NextVectorIterCore($1, $2)
	$$.uint_val = si.iter;
	si.IterFinished();

internal-op Next-Vector-Blank-Iter
# v1 = iteration info
# v2 = branch target if loop done
op1-internal
type ii
eval	NextVectorIterCore($1, $2)
	si.IterFinished();

internal-op Next-Vector-Iter-Val-Var
# v1 = iteration variable
# v2 = value variable
# v3 = iteration info
# v4 = branch target if loop done
op1-read-write
type VVii
eval	NextVectorIterCore($2, $3)
	$$.uint_val = si.iter;
	if ( z.is_managed )
		$1 = BuildVal(vv[si.iter]->ToVal(z.t), z.t);
	else
		$1 = *vv[si.iter];
	si.IterFinished();

internal-op Next-Vector-Blank-Iter-Val-Var
# v1 = value variable
# v2 = iteration info
# v3 = branch target if loop done
type Vii
eval	NextVectorIterCore($1, $2)
	if ( z.is_managed )
		$$ = BuildVal(vv[si.iter]->ToVal(z.t), z.t);
	else
		$$ = *vv[si.iter];
	si.IterFinished();


internal-op Init-String-Loop
type Vi
op1-read
eval	step_iters[$2].InitLoop($1.string_val->AsString());

internal-op Init-String-Loop
op1-read
type iC
eval	step_iters[$1].InitLoop($2.string_val->AsString());

internal-op Next-String-Iter
# v1 = iteration variable
# v2 = iteration info
# v3 = branch target if loop done
type Vii
eval	auto& si = step_iters[$1];
	if ( si.IsDoneIterating() )
		BRANCH($2)
	auto bytes = (const char*) si.s->Bytes() + si.iter;
	auto sv = new StringVal(1, bytes);
	Unref($$.string_val);
	$$.string_val = sv;
	si.IterFinished();

internal-op Next-String-Blank-Iter
# v1 = iteration info
# v2 = branch target if loop done
op1-internal
type ii
eval	auto& si = step_iters[$1];
	if ( si.IsDoneIterating() )
		BRANCH($2)
	si.IterFinished();

internal-op End-Table-Loop
op1-internal
type i
eval    (*tiv_ptr)[$1].Clear();


op CheckAnyLen
op1-read
type Vi
eval	auto v = $1.list_val;
	if ( v->Vals().size() != static_cast<zeek_uint_t>($2) )
		ZAM_run_time_error(z.loc, "mismatch in list lengths");

op Print
type O
eval	do_print_stmt(z.aux->ToValVec(frame));
method-post z.aux = v->aux;

op Print1
op1-read
type V
set-type $$
eval	EvalPrint1($$)

macro EvalPrint1(value)
	std::vector<ValPtr> vals;
	vals.push_back(value.ToVal(z.t));
	do_print_stmt(vals);

op Print1
op1-read
type C
set-type $$
eval	EvalPrint1($1)


internal-op If-Else
op1-read
type Vi
eval	if ( ! $1.int_val ) BRANCH($2)

internal-op If
op1-read
type Vi
eval	if ( ! $1.int_val ) BRANCH($2)

internal-op If-Not
op1-read
type Vi
eval	if ( $1.int_val ) BRANCH($2)


op AddStmt
op1-read
type VO
eval	EvalAddStmt($1, z.aux->ToListVal(frame))
method-post z.aux = v->aux;

macro EvalAddStmt(lhs, ind)
	auto index = ind;
	bool iterators_invalidated = false;
	lhs.table_val->Assign(std::move(index), nullptr, true, &iterators_invalidated);
	if ( iterators_invalidated )
		ZAM_run_time_warning(z.loc, "possible loop/iterator invalidation");

op AddStmt1
op1-read
set-type $1
type VV
eval	EvalAddStmt($1, $2.ToVal(z.t))

op AddStmt1
op1-read
type VC
eval	EvalAddStmt($1, $2.ToVal(z.t))


op ClearTable
op1-read
type V
eval	$1.table_val->RemoveAll();

op ClearVector
op1-read
type V
eval	$1.vector_val->Resize(0);


op DelTable
op1-read
type VO
eval	auto index = z.aux->ToListVal(frame);
	bool iterators_invalidated = false;
	$1.table_val->Remove(*index, true, &iterators_invalidated);
	if ( iterators_invalidated )
		ZAM_run_time_warning(z.loc, "possible loop/iterator invalidation");
method-post z.aux = v->aux;

op DelField
op1-read
type Vi
eval	$1.record_val->Remove($2);


internal-op Init-Record
type V
eval	auto r = new RecordVal(cast_intrusive<RecordType>(z.t));
	Unref($$.record_val);
	$$.record_val = r;

internal-op Init-Vector
type V
eval	auto vt = cast_intrusive<VectorType>(z.t);
	auto vec = new VectorVal(std::move(vt));
	Unref($$.vector_val);
	$$.vector_val = vec;

internal-op Init-Table
type V
eval	auto tt = cast_intrusive<TableType>(z.t);
	auto t = new TableVal(tt, z.aux->attrs);
	Unref($$.table_val);
	$$.table_val = t;

op When
type V
op1-read
eval	BuildWhen($1, -1.0)

op When-Timeout
type VV
op1-read
eval	BuildWhen($1, $2.double_val)

op When-Timeout
type VC
op1-read
eval	BuildWhen($1, $2.double_val)

macro BuildWhen(f, timeout)
	auto& aux = z.aux;
	auto wi = aux->wi;
	FuncPtr func{NewRef{}, f.func_val};
	auto lambda = make_intrusive<FuncVal>(func);
	wi->Instantiate(std::move(lambda));
	std::vector<ValPtr> local_aggrs;
	for ( int i = 0; i < aux->n; ++i )
		{
		auto v = aux->ToVal(frame, i);
		if ( v )
			local_aggrs.push_back(v);
		}
	(void)make_intrusive<trigger::Trigger>(wi, wi->WhenExprGlobals(), local_aggrs, timeout, f, z.loc->Loc());

########################################
# Internal
########################################

# These two are only needed for type-based switch statements.  Could think
# about replacing them using CoerceFromAnyExpr.
op Assign-Any
type VV
set-type $1
eval	EvalAssignAny($$, $1)

macro EvalAssignAny(lhs, value)
	auto v = value.ToVal(z.t);
	lhs.any_val = v.release();

op Assign-Any
type VC
set-type $1
eval	EvalAssignAny($$, $1)

# Lazy way to assign without having to track the specific type of
# a constant.
internal-op Assign-Const
type VC
eval	AssignTarget($$, BuildVal($1.ToVal(z.t), z.t))

internal-assignment-op Load-Val
type VV
assign-val v
eval	auto& v = f->GetElement(z.v2);

internal-assignment-op Load-Global
type VV
assign-val v
eval	auto& v = globals[z.v2].id->GetVal();
	if ( ! v )
		{
		ZAM_run_time_error(z.loc, "value used but not set", z.aux->id_val.get());
		break;
		}

# We need a special form here for loading global types, as they don't
# fit the usual template.
internal-op Load-Global-Type
type Vi
eval	auto& v = $$.type_val;
	Unref(v);
	auto& t = globals[$1].id->GetType();
	v = new TypeVal(t, true);

internal-op Load-Capture
type Vi
eval	$$ = f->GetFunction()->GetCapturesVec()[$1];

internal-op Load-Managed-Capture
type Vi
eval	auto& lhs = $$;
	auto& rhs = f->GetFunction()->GetCapturesVec()[$1];
	zeek::Ref(rhs.ManagedVal());
	ZVal::DeleteManagedType(lhs);
	lhs = rhs;

internal-op Store-Global
op1-internal
type i
eval	auto& g = globals[$1];
	g.id->SetVal(frame[g.slot].ToVal(z.t));

# Both of these have the LHS as v2 not v1, to keep with existing
# conventions of OP_VV_I2 op type (as opposed to OP_VV_I1_V2, which doesn't
# currently exist, and would be a pain to add).
internal-op Store-Capture
op1-read
type Vi
eval	f->GetFunction()->GetCapturesVec()[$2] = $1;

internal-op Store-Managed-Capture
op1-read
type Vi
eval	auto& lhs = f->GetFunction()->GetCapturesVec()[$2];
	auto& rhs = $1;
	zeek::Ref(rhs.ManagedVal());
	ZVal::DeleteManagedType(lhs);
	lhs = rhs;


internal-op Copy-To
type VC
set-type $1
eval	AssignTarget($$, CopyVal($1))

internal-op GoTo
type i
eval	BRANCH($1)

internal-op Hook-Break
type X
eval	flow = FLOW_BREAK;
	pc = end_pc;
	DO_ZAM_PROFILE
	continue;

# Slot 2 gives frame size.
internal-op Lambda
type Vi
eval	auto& aux = z.aux;
	auto& primary_func = aux->primary_func;
	auto& body = primary_func->GetBodies()[0].stmts;
	ASSERT(body->Tag() == STMT_ZAM);
	auto lamb = make_intrusive<ScriptFunc>(aux->id_val);
	lamb->AddBody(body, $1);
	lamb->SetName(aux->lambda_name.c_str());
	if ( aux->n > 0 )
		{
		auto captures = std::make_unique<std::vector<ZVal>>();
		for ( auto i = 0; i < aux->n; ++i )
			{
			auto slot = aux->elems[i].Slot();
			if ( slot >= 0 )
				{
				auto& cp = frame[slot];
				if ( aux->elems[i].IsManaged() )
					zeek::Ref(cp.ManagedVal());
				captures->push_back(cp);
				}
			else
				// Used for when-locals.
				captures->push_back(ZVal());
			}
		lamb->CreateCaptures(std::move(captures));
		}
	ZVal::DeleteManagedType($$);
	$$.func_val = lamb.release();

########################################
# Built-in Functions
########################################

internal-op Remove-Teredo
op1-read
type V
eval	auto teredo = zeek::packet_mgr->GetAnalyzer("Teredo");
	if ( teredo )
		{
		zeek::detail::ConnKey conn_key($1.record_val);
		static_cast<zeek::packet_analysis::teredo::TeredoAnalyzer*>(teredo.get())->RemoveConnection(conn_key);
		}

internal-op Remove-Teredo
side-effects OP_REMOVE_TEREDO_V OP_V
type VV
eval	auto teredo = zeek::packet_mgr->GetAnalyzer("Teredo");
	if ( teredo )
		{
		zeek::detail::ConnKey conn_key($1.record_val);
		static_cast<zeek::packet_analysis::teredo::TeredoAnalyzer*>(teredo.get())->RemoveConnection(conn_key);
		}
	$$.int_val = 1;

internal-op Remove-GTPv1
op1-read
type V
eval	auto gtpv1 = zeek::packet_mgr->GetAnalyzer("GTPv1");
	if ( gtpv1 )
		{
		zeek::detail::ConnKey conn_key($1.record_val);
		static_cast<zeek::packet_analysis::gtpv1::GTPv1_Analyzer*>(gtpv1.get())->RemoveConnection(conn_key);
		}

internal-op Remove-GTPv1
side-effects OP_REMOVE_GTPV1_V OP_V
type VV
eval	auto gtpv1 = zeek::packet_mgr->GetAnalyzer("GTPv1");
	if ( gtpv1 )
		{
		zeek::detail::ConnKey conn_key($1.record_val);
		static_cast<zeek::packet_analysis::gtpv1::GTPv1_Analyzer*>(gtpv1.get())->RemoveConnection(conn_key);
		}
	$$.int_val = 1;

internal-op Set-File-Handle
op1-read
type V
eval	auto handle = $1.string_val;
	auto bytes = reinterpret_cast<const char*>(handle->Bytes());
	auto h = std::string(bytes, handle->Len());
	zeek::file_mgr->SetHandle(h);

internal-op Subnet-To-Addr
type VV
eval	auto addr_v = make_intrusive<AddrVal>($1.subnet_val->Prefix());
	Unref($$.addr_val);
	$$ = ZVal(addr_v);

macro EvalSubBytes(lhs, arg1, arg2, arg3)
	{
	auto sv = ZAM_sub_bytes(arg1.AsString(), arg2, arg3);
	Unref(lhs.AsString());
	lhs.string_val = sv;
	}

internal-op Sub-Bytes
type VVVV
eval	EvalSubBytes($$, $1, $2.uint_val, $3.int_val)

internal-op Sub-Bytes
type VVVC
eval	EvalSubBytes($$, $1, $2.uint_val, $3.int_val)

internal-op Sub-Bytes
type VVCV
eval	EvalSubBytes($$, $1, $2.uint_val, $3.int_val)

internal-op Sub-Bytes
type VVCi
eval	EvalSubBytes($$, $1, $2.uint_val, $3)

### The next ones are weird
internal-op Sub-Bytes
type VVVC
eval	EvalSubBytes($$, $3, $1.uint_val, $2.uint_val)

internal-op Sub-Bytes
type VViC
eval	EvalSubBytes($$, $3, $1.uint_val, $2)

internal-op Sub-Bytes
type ViVC
eval	EvalSubBytes($$, $3, zeek_uint_t($2), $1.uint_val)

internal-op Time-To-Double
type VV
eval	$$ = $1;


internal-op To-Lower
type VV
eval	auto sv = ZAM_to_lower($1.string_val);
	Unref($$.string_val);
	$$.string_val = sv;

# A ZAM version of Log::__write.  In calls to it, the first argument
# is generally a constant (enum) *if we inlined*, but otherwise a
# parameter, so we support both VVV ad VVC.
#
# It's actually the case that the return value is pretty much always
# ignored ... plus optimization can elide it away.  See the second
# pair of built-ins for versions that discard the return value.
#
# Could speed things up further by modifying the Write method to just
# take the raw enum value, as it appears that that's all that's ever
# actually used.

macro LogWritePre(id_val, columns)
	auto id = id_val.ToVal(ZAM::log_ID_enum_type);
	auto columns = columns.record_val;

macro LogWriteResPost(lhs)
	bool result = log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal());
	lhs.int_val = result;

macro LogWriteNoResPost()
	(void) log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal());

internal-op Log-Write
side-effects OP_LOG_WRITE_VV OP_VV
type VVV
eval	LogWritePre($1, $2)
	LogWriteResPost($$)

### Check that invoked correctly
internal-op Log-WriteC
side-effects OP_LOG_WRITEC_V OP_V
type VCV
eval	LogWritePre($1, $2)
	LogWriteResPost($$)

# Versions that discard the return value.
internal-op Log-Write
side-effects
op1-read
type VV
eval	LogWritePre($1, $2)
	LogWriteNoResPost()

internal-op Log-WriteC
side-effects
op1-read
type CV
eval	LogWritePre($1, $2)
	LogWriteNoResPost()

internal-op Broker-Flush-Logs
side-effects OP_BROKER_FLUSH_LOGS_X OP_X
type V
eval	$$.uint_val = broker_mgr->FlushLogBuffers();

internal-op Broker-Flush-Logs
side-effects
type X
eval	(void) broker_mgr->FlushLogBuffers();

internal-op Get-Port-Transport-Proto
type VV
eval	auto mask = $1.uint_val & PORT_SPACE_MASK;
	auto v = 0; /* TRANSPORT_UNKNOWN */
	if ( mask == TCP_PORT_MASK )
		v = 1;
	else if ( mask == UDP_PORT_MASK )
		v = 2;
	else if ( mask == ICMP_PORT_MASK )
		v = 3;
	$$.uint_val = v;

internal-op Conn-Exists
type VV
eval	$$.int_val = session_mgr->FindConnection($1.record_val) != nullptr;

internal-op Conn-Exists-Cond
op1-read
type Vi
eval	if ( ! session_mgr->FindConnection($1.record_val) )
		BRANCH($2)

internal-op Not-Conn-Exists-Cond
op1-read
type Vi
eval	if ( session_mgr->FindConnection($1.record_val) )
		BRANCH($2)

internal-op Lookup-Conn
type VV
eval	auto cid = $1.record_val;
	Connection* conn = session_mgr->FindConnection(cid);
	ValPtr res;
	if ( conn )
		res = conn->GetVal();
	else
		{
		ZAM_run_time_error(z.loc, "connection ID not a known connection", cid);
		res = build_dummy_conn_record();
		}
	AssignTarget($$, ZVal(res, res->GetType()));

internal-op Is-ICMP-Port
type VV
eval	$$.int_val = ($1.uint_val & PORT_SPACE_MASK) == ICMP_PORT_MASK;

internal-op Is-ICMP-Port-Cond
op1-read
type Vi
eval	if ( ($1.uint_val & PORT_SPACE_MASK) != ICMP_PORT_MASK )
		BRANCH($2)

internal-op Not-Is-ICMP-Port-Cond
op1-read
type Vi
eval	if ( ($1.uint_val & PORT_SPACE_MASK) == ICMP_PORT_MASK )
		BRANCH($2)

internal-op Is-TCP-Port
type VV
eval	$$.int_val = ($1.uint_val & PORT_SPACE_MASK) == TCP_PORT_MASK;

internal-op Is-TCP-Port-Cond
op1-read
type Vi
eval	if ( ($1.uint_val & PORT_SPACE_MASK) != TCP_PORT_MASK )
		BRANCH($2)

internal-op Not-Is-TCP-Port-Cond
op1-read
type Vi
eval	if ( ($1.uint_val & PORT_SPACE_MASK) == TCP_PORT_MASK )
		BRANCH($2)

internal-op Is-UDP-Port
type VV
eval	$$.int_val = ($1.uint_val & PORT_SPACE_MASK) == UDP_PORT_MASK;

internal-op Is-UDP-Port-Cond
op1-read
type Vi
eval	if ( ($1.uint_val & PORT_SPACE_MASK) != UDP_PORT_MASK )
		BRANCH($2)

internal-op Not-Is-UDP-Port-Cond
op1-read
type Vi
eval	if ( ($1.uint_val & PORT_SPACE_MASK) == UDP_PORT_MASK )
		BRANCH($2)

internal-op Is-V4-Addr
type VV
eval	$$.int_val = $1.addr_val->AsAddr().GetFamily() == IPv4;

internal-op Is-V4-Addr-Cond
op1-read
type Vi
eval	if ( $1.addr_val->AsAddr().GetFamily() != IPv4 )
		BRANCH($2)

internal-op Not-Is-V4-Addr-Cond
op1-read
type Vi
eval	if ( $1.addr_val->AsAddr().GetFamily() == IPv4 )
		BRANCH($2)

internal-op Is-V6-Addr
type VV
eval	$$.int_val = $1.addr_val->AsAddr().GetFamily() == IPv6;

internal-op Is-V6-Addr-Cond
op1-read
type Vi
eval	if ( $1.addr_val->AsAddr().GetFamily() != IPv6 )
		BRANCH($2)

internal-op Not-Is-V6-Addr-Cond
op1-read
type Vi
eval	if ( $1.addr_val->AsAddr().GetFamily() == IPv6 )
		BRANCH($2)

internal-op Network-Time
type V
eval	$$.double_val = run_state::network_time;

internal-op Current-Time
type V
eval	$$.double_val = util::current_time();

internal-op Reading-Live-Traffic
type V
eval	$$.int_val = run_state::reading_live;

internal-op Reading-Live-Traffic-Cond
op1-read
type i
eval	if ( ! run_state::reading_live )
		BRANCH($1)

internal-op Not-Reading-Live-Traffic-Cond
op1-read
type i
eval	if ( run_state::reading_live )
		BRANCH($1)

internal-op Reading-Traces
type V
eval	$$.int_val = run_state::reading_traces;

internal-op Reading-Traces-Cond
op1-read
type i
eval	if ( ! run_state::reading_traces )
		BRANCH($1)

internal-op Not-Reading-Traces-Cond
op1-read
type i
eval	if ( run_state::reading_traces )
		BRANCH($1)

internal-op Sort
op1-read
type V
eval	if ( $1.vector_val->Size() > 1 )
		$1.vector_val->Sort();

internal-op Sort
type VV
eval	auto vv = $1.vector_val;
	if ( vv->Size() > 1 )
		vv->Sort();
	zeek::Ref(vv);
	Unref($$.vector_val);
	$$.vector_val = vv;

internal-op Sort-With-Cmp
op1-read
type VV
eval	if ( $1.vector_val->Size() > 1 )
		$1.vector_val->Sort($2.func_val);

internal-op Sort-With-Cmp
type VVV
eval	auto vv = $1.vector_val;
	if ( vv->Size() > 1 )
		vv->Sort($2.func_val);
	zeek::Ref(vv);
	Unref($$.vector_val);
	$$.vector_val = vv;

macro EvalStartsWith(lhs, str_val, sub_val)
	auto str = str_val.string_val;
	auto sub = sub_val.string_val;
	auto str_n = str->Len();
	auto sub_n = sub->Len();
	if ( str_n < sub_n )
		lhs.int_val = 0;
	else
		{
		auto str_b = str->Bytes();
		auto sub_b = sub->Bytes();
		int i;
		for ( i = 0; i < sub_n; ++i )
			if ( str_b[i] != sub_b[i] )
				break;
		lhs.int_val = i == sub_n;
		}

internal-op Starts-With
type VVV
eval	EvalStartsWith($$, $1, $2)

internal-op Starts-With
type VCV
eval	EvalStartsWith($$, $1, $2)

internal-op Starts-With
type VVC
eval	EvalStartsWith($$, $1, $2)

macro EvalStrCmp(lhs, s1_src, s2_src)
	auto s1 = s1_src.string_val;
	auto s2 = s2_src.string_val;
	lhs.int_val = Bstr_cmp(s1->AsString(), s2->AsString());

internal-op StrCmp
type VVV
eval	EvalStrCmp($$, $1, $2)

internal-op StrCmp
type VCV
eval	EvalStrCmp($$, $1, $2)

internal-op StrCmp
type VVC
eval	EvalStrCmp($$, $1, $2)

macro EvalStrStr(lhs, big_value, little_value)
	auto big = big_value.string_val;
	auto little = little_value.string_val;
	lhs.int_val = 1 + big->AsString()->FindSubstring(little->AsString());

internal-op StrStr
type VVV
eval	EvalStrStr($$, $1, $2)

internal-op StrStr
type VCV
eval	EvalStrStr($$, $1, $2)

internal-op StrStr
type VVC
eval	EvalStrStr($$, $1, $2)

macro Cat1Op(lhs, val)
	auto& v1 = lhs;
	ZVal::DeleteManagedType(v1);
	v1 = val;

macro Cat1OpRef(lhs, val)
	Cat1Op(lhs, val)
	zeek::Ref(v1.string_val);

internal-op Cat1
type VC
eval	Cat1OpRef($$, $1)

internal-op Cat1
type VV
eval	Cat1OpRef($$, $1)

macro Cat1FullVal(lhs, val)
	auto formatted_val = ZVal(ZAM_val_cat(val.ToVal(z.t)));
	Cat1Op(lhs, formatted_val)

internal-op Cat1Full
type VC
eval	Cat1FullVal($$, $1)

internal-op Cat1Full
type VV
eval	Cat1FullVal($$, $1)

internal-op CatN
type V
eval	auto aux = z.aux;
	auto& ca = aux->cat_args;
	int n = aux->n;
	size_t max_size = 0;
	for ( int i = 0; i < n; ++i )
		max_size += ca[i]->MaxSize(frame, aux->elems[i].Slot());
	auto res = new char[max_size + /* slop */ n + 1];
	auto res_p = res;
	for ( int i = 0; i < n; ++i )
		ca[i]->RenderInto(frame, aux->elems[i].Slot(), res_p);
	*res_p = '\0';
	auto s = new String(true, reinterpret_cast<byte_vec>(res), res_p - res);
	Cat1Op($$, ZVal(new StringVal(s)))

macro CatNPre()
	auto aux = z.aux;
	auto& ca = aux->cat_args;

macro CatNMid()
	auto res = new char[max_size + /* slop */ 10];
	auto res_p = res;

macro CatNPost(lhs)
	*res_p = '\0';
	auto s = new String(true, reinterpret_cast<byte_vec>(res), res_p - res);
	Cat1Op(lhs, ZVal(new StringVal(s)))

internal-op Cat2
type V
eval	CatNPre()
	size_t max_size = ca[0]->MaxSize(frame, aux->elems[0].Slot());
	max_size += ca[1]->MaxSize(frame, aux->elems[1].Slot());
	CatNMid()
	ca[0]->RenderInto(frame, aux->elems[0].Slot(), res_p);
	ca[1]->RenderInto(frame, aux->elems[1].Slot(), res_p);
	CatNPost($$)

internal-op Cat3
type V
eval	CatNPre()
	size_t max_size = ca[0]->MaxSize(frame, aux->elems[0].Slot());
	max_size += ca[1]->MaxSize(frame, aux->elems[1].Slot());
	max_size += ca[2]->MaxSize(frame, aux->elems[2].Slot());
	CatNMid()
	ca[0]->RenderInto(frame, aux->elems[0].Slot(), res_p);
	ca[1]->RenderInto(frame, aux->elems[1].Slot(), res_p);
	ca[2]->RenderInto(frame, aux->elems[2].Slot(), res_p);
	CatNPost($$)

internal-op Cat4
type V
eval	CatNPre()
	size_t max_size = ca[0]->MaxSize(frame, aux->elems[0].Slot());
	max_size += ca[1]->MaxSize(frame, aux->elems[1].Slot());
	max_size += ca[2]->MaxSize(frame, aux->elems[2].Slot());
	max_size += ca[3]->MaxSize(frame, aux->elems[3].Slot());
	CatNMid()
	ca[0]->RenderInto(frame, aux->elems[0].Slot(), res_p);
	ca[1]->RenderInto(frame, aux->elems[1].Slot(), res_p);
	ca[2]->RenderInto(frame, aux->elems[2].Slot(), res_p);
	ca[3]->RenderInto(frame, aux->elems[3].Slot(), res_p);
	CatNPost($$)

internal-op Cat5
type V
eval	CatNPre()
	size_t max_size = ca[0]->MaxSize(frame, aux->elems[0].Slot());
	max_size += ca[1]->MaxSize(frame, aux->elems[1].Slot());
	max_size += ca[2]->MaxSize(frame, aux->elems[2].Slot());
	max_size += ca[3]->MaxSize(frame, aux->elems[3].Slot());
	max_size += ca[4]->MaxSize(frame, aux->elems[4].Slot());
	CatNMid()
	ca[0]->RenderInto(frame, aux->elems[0].Slot(), res_p);
	ca[1]->RenderInto(frame, aux->elems[1].Slot(), res_p);
	ca[2]->RenderInto(frame, aux->elems[2].Slot(), res_p);
	ca[3]->RenderInto(frame, aux->elems[3].Slot(), res_p);
	ca[4]->RenderInto(frame, aux->elems[4].Slot(), res_p);
	CatNPost($$)

internal-op Cat6
type V
eval	CatNPre()
	size_t max_size = ca[0]->MaxSize(frame, aux->elems[0].Slot());
	max_size += ca[1]->MaxSize(frame, aux->elems[1].Slot());
	max_size += ca[2]->MaxSize(frame, aux->elems[2].Slot());
	max_size += ca[3]->MaxSize(frame, aux->elems[3].Slot());
	max_size += ca[4]->MaxSize(frame, aux->elems[4].Slot());
	max_size += ca[5]->MaxSize(frame, aux->elems[5].Slot());
	CatNMid()
	ca[0]->RenderInto(frame, aux->elems[0].Slot(), res_p);
	ca[1]->RenderInto(frame, aux->elems[1].Slot(), res_p);
	ca[2]->RenderInto(frame, aux->elems[2].Slot(), res_p);
	ca[3]->RenderInto(frame, aux->elems[3].Slot(), res_p);
	ca[4]->RenderInto(frame, aux->elems[4].Slot(), res_p);
	ca[5]->RenderInto(frame, aux->elems[5].Slot(), res_p);
	CatNPost($$)

internal-op Cat7
type V
eval	CatNPre()
	size_t max_size = ca[0]->MaxSize(frame, aux->elems[0].Slot());
	max_size += ca[1]->MaxSize(frame, aux->elems[1].Slot());
	max_size += ca[2]->MaxSize(frame, aux->elems[2].Slot());
	max_size += ca[3]->MaxSize(frame, aux->elems[3].Slot());
	max_size += ca[4]->MaxSize(frame, aux->elems[4].Slot());
	max_size += ca[5]->MaxSize(frame, aux->elems[5].Slot());
	max_size += ca[6]->MaxSize(frame, aux->elems[6].Slot());
	CatNMid()
	ca[0]->RenderInto(frame, aux->elems[0].Slot(), res_p);
	ca[1]->RenderInto(frame, aux->elems[1].Slot(), res_p);
	ca[2]->RenderInto(frame, aux->elems[2].Slot(), res_p);
	ca[3]->RenderInto(frame, aux->elems[3].Slot(), res_p);
	ca[4]->RenderInto(frame, aux->elems[4].Slot(), res_p);
	ca[5]->RenderInto(frame, aux->elems[5].Slot(), res_p);
	ca[6]->RenderInto(frame, aux->elems[6].Slot(), res_p);
	CatNPost($$)

internal-op Cat8
type V
eval	CatNPre()
	size_t max_size = ca[0]->MaxSize(frame, aux->elems[0].Slot());
	max_size += ca[1]->MaxSize(frame, aux->elems[1].Slot());
	max_size += ca[2]->MaxSize(frame, aux->elems[2].Slot());
	max_size += ca[3]->MaxSize(frame, aux->elems[3].Slot());
	max_size += ca[4]->MaxSize(frame, aux->elems[4].Slot());
	max_size += ca[5]->MaxSize(frame, aux->elems[5].Slot());
	max_size += ca[6]->MaxSize(frame, aux->elems[6].Slot());
	max_size += ca[7]->MaxSize(frame, aux->elems[7].Slot());
	CatNMid()
	ca[0]->RenderInto(frame, aux->elems[0].Slot(), res_p);
	ca[1]->RenderInto(frame, aux->elems[1].Slot(), res_p);
	ca[2]->RenderInto(frame, aux->elems[2].Slot(), res_p);
	ca[3]->RenderInto(frame, aux->elems[3].Slot(), res_p);
	ca[4]->RenderInto(frame, aux->elems[4].Slot(), res_p);
	ca[5]->RenderInto(frame, aux->elems[5].Slot(), res_p);
	ca[6]->RenderInto(frame, aux->elems[6].Slot(), res_p);
	ca[7]->RenderInto(frame, aux->elems[7].Slot(), res_p);
	CatNPost($$)

macro AnalyzerName(lhs, tag)
	auto atype = tag.ToVal(z.t);
	auto val = atype->AsEnumVal();
	Unref(lhs.string_val);
	plugin::Component* component = zeek::analyzer_mgr->Lookup(val);
	if ( ! component )
		component = zeek::packet_mgr->Lookup(val);
	if ( ! component )
		component = zeek::file_mgr->Lookup(val);
	if ( component )
		lhs.string_val = new StringVal(component->CanonicalName());
	else
		lhs.string_val = new StringVal("<error>");

internal-op Analyzer-Name
type VV
eval	AnalyzerName($$, $1)

internal-op Analyzer-Name
type VC
eval	AnalyzerName($$, $1)

macro FilesAddOrRemoveAnalyzer(file_id_val, tag, args_val, METHOD)
	auto file_id = file_id_val.string_val;
	using zeek::BifType::Record::Files::AnalyzerArgs;
	auto rv = args_val.record_val->CoerceTo(AnalyzerArgs);
	bool result = zeek::file_mgr->METHOD(
	     file_id->CheckString(),
	     zeek::file_mgr->GetComponentTag(tag.ToVal(z.t).get()),
	     std::move(rv));

macro FilesAddAnalyzer(file_id_val, tag, args_val)
	FilesAddOrRemoveAnalyzer(file_id_val, tag, args_val, AddAnalyzer)

internal-op Files-Add-Analyzer
op1-read
type VVV
eval	FilesAddAnalyzer($1, $2, $3)

internal-op Files-Add-Analyzer
op1-read
type VCV
eval	FilesAddAnalyzer($1, $2, $3)

internal-op Files-Add-Analyzer
type VVVV
side-effects OP_FILES_ADD_ANALYZER_VVV OP_VVV
eval	FilesAddAnalyzer($1, $2, $3)
	$$.int_val = result;

internal-op Files-Add-Analyzer
type VVCV
side-effects OP_FILES_ADD_ANALYZER_VCV OP_VVC
eval	FilesAddAnalyzer($1, $2, $3)
	$$.int_val = result;

macro FilesRemoveAnalyzer(file_id_val, tag, args_slot)
	FilesAddOrRemoveAnalyzer(file_id_val, tag, args_slot, RemoveAnalyzer)

internal-op Files-Remove-Analyzer
op1-read
type VVV
eval	FilesRemoveAnalyzer($1, $2, $3)

internal-op Files-Remove-Analyzer
op1-read
type ViV
eval	FilesRemoveAnalyzer($1, $2, $3)

internal-op Files-Remove-Analyzer
type VVVV
side-effects OP_FILES_REMOVE_ANALYZER_VVV OP_VVV
eval	FilesRemoveAnalyzer($1, $2, $3)
	$$.int_val = result;

internal-op Files-Remove-Analyzer
type VVCV
side-effects OP_FILES_REMOVE_ANALYZER_VCV OP_VVC
eval	FilesRemoveAnalyzer($1, $2, $3)
	$$.int_val = result;

macro AnalyzerEnabled(lhs, tag)
	auto atype = tag.ToVal(z.t);
	auto c = zeek::file_mgr->Lookup(atype->AsEnumVal());
	lhs.int_val = c && c->Enabled();

internal-op Analyzer-Enabled
type VV
eval	AnalyzerEnabled($$, $1)

internal-op Analyzer-Enabled
type VC
eval	AnalyzerEnabled($$, $1)

macro FileAnalyzerName(lhs, tag)
	auto atype = tag.ToVal(z.t);
	Unref(lhs.string_val);
	lhs = ZVal(file_mgr->GetComponentNameVal({NewRef{}, atype->AsEnumVal()}));

internal-op File-Analyzer-Name
type VV
eval	FileAnalyzerName($$, $1)

internal-op File-Analyzer-Name
type VC
eval	FileAnalyzerName($$, $1)

macro IsProtocolAnalyzer(lhs, tag)
	auto atype = tag.ToVal(z.t);
	lhs.int_val = analyzer_mgr->Lookup(atype->AsEnumVal()) != nullptr;

internal-op Is-Protocol-Analyzer
type VV
eval	IsProtocolAnalyzer($$, $1)

internal-op Is-Protocol-Analyzer
type VC
eval	IsProtocolAnalyzer($$, $1)

internal-op Clear-Table
op1-read
type V
eval	$1.table_val->RemoveAll();

internal-op Files-Enable-Reassembly
op1-read
type V
eval	auto f = $1.string_val->CheckString();
	file_mgr->EnableReassembly(f);

internal-op Files-Set-Reassembly-Buffer
op1-read
type VV
eval	auto f = $1.string_val->CheckString();
	file_mgr->SetReassemblyBuffer(f, $2.uint_val);

internal-op Files-Set-Reassembly-Buffer
type VVV
side-effects OP_FILES_SET_REASSEMBLY_BUFFER_VV OP_VV
eval	auto f = $1.string_val->CheckString();
	$$.int_val = file_mgr->SetReassemblyBuffer(f, $2.uint_val);

internal-op Files-Set-Reassembly-Buffer
op1-read
type Vi
eval	auto f = $1.string_val->CheckString();
	file_mgr->SetReassemblyBuffer(f, zeek_uint_t($2));

internal-op Files-Set-Reassembly-Buffer
type VVi
side-effects OP_FILES_SET_REASSEMBLY_BUFFER_VC OP_VC
eval	auto f = $1.string_val->CheckString();
	$$.int_val = file_mgr->SetReassemblyBuffer(f, zeek_uint_t($2));

macro GetBytesThresh(lhs, cid, is_orig)
	zeek::analyzer::Analyzer* a = analyzer::conn_size::GetConnsizeAnalyzer(cid);
	auto res = 0U;
	if ( a )
		res = static_cast<analyzer::conn_size::ConnSize_Analyzer*>(a)->GetByteAndPacketThreshold(true, is_orig);
	lhs.uint_val = res;

internal-op Get-Bytes-Thresh
type VVV
eval	GetBytesThresh($$, $1.record_val, $2.int_val)

internal-op Get-Bytes-Thresh
type VVC
eval	GetBytesThresh($$, $1.record_val, $2.int_val)

macro SetBytesThresh(cid, threshold, is_orig)
	bool res = false;
	zeek::analyzer::Analyzer* a = analyzer::conn_size::GetConnsizeAnalyzer(cid);
	if ( a )
		{
		static_cast<analyzer::conn_size::ConnSize_Analyzer*>(a)->SetByteAndPacketThreshold(threshold, true, is_orig);
		res = true;
		}

internal-op Set-Bytes-Thresh
op1-read
type VVV
eval	SetBytesThresh($1.record_val, $2.uint_val, $3.int_val)

internal-op Set-Bytes-Thresh
op1-read
type VVC
eval	SetBytesThresh($1.record_val, $2.uint_val, $3.int_val)

internal-op Set-Bytes-Thresh
op1-read
type VCV
eval	SetBytesThresh($1.record_val, $2.uint_val, $3.int_val)

internal-op Set-Bytes-Thresh
op1-read
type VCi
eval	SetBytesThresh($1.record_val, $2.uint_val, $3)

internal-op Set-Bytes-Thresh
type VVVV
side-effects OP_SET_BYTES_THRESH_VVV OP_VVV
eval	SetBytesThresh($1.record_val, $2.uint_val, $3.int_val)
	$$.int_val = res;

internal-op Set-Bytes-Thresh
type VVVC
side-effects OP_SET_BYTES_THRESH_VVC OP_VVV
eval	SetBytesThresh($1.record_val, $2.uint_val, $3.int_val)
	$$.int_val = res;

internal-op Set-Bytes-Thresh
type VVCV
side-effects OP_SET_BYTES_THRESH_VCV OP_VVV
eval	SetBytesThresh($1.record_val, $2.uint_val, $3.int_val)
	$$.int_val = res;

internal-op Set-Bytes-Thresh
type VVCi
side-effects OP_SET_BYTES_THRESH_VCi OP_VVC_I2
eval	SetBytesThresh($1.record_val, $2.uint_val, zeek_uint_t($3))
	$$.int_val = res;

########################################
# Instructions for known script functions
########################################

internal-op Func-Id-String
type VV
eval	auto id_rec = $1.record_val;
	auto orig_h = id_rec->RawField(0).addr_val->AsAddr().AsString();
	auto resp_h = id_rec->RawField(2).addr_val->AsAddr().AsString();
	auto orig_p = static_cast<uint32_t>(id_rec->RawField(1).uint_val) & ~PORT_SPACE_MASK;
	auto resp_p = static_cast<uint32_t>(id_rec->RawField(3).uint_val) & ~PORT_SPACE_MASK;
	/* Maximum address size is for IPv6 with no compression. Each
	 * 8 16-bit hex elements plus 7 colons between them plus the two []'s
	 * = 8*4 + 7 + 2 = 41 characters.
	 *
	 * Maximum port size is 5.
	 *
	 * Two of these = 2*41 + 2*5 = 92.
	 * Other delimiters: two ':', one ' < ' for 5 more.
	 *
	 * TOTAL: 97 characters.
	 *
	 * We use considerably more for safety.
	 */
	char buf[128];
	snprintf(buf, sizeof buf, "%s:%u > %s:%u", orig_h.c_str(), orig_p, resp_h.c_str(), resp_p);
	Unref($$.string_val);
	$$.string_val = new StringVal(buf);

########################################
# Instructions for script-level idioms
########################################

internal-op MinU
type VVC
eval	$$.uint_val = std::min($1.uint_val, $2.uint_val);

internal-op MinI
type VVC
eval	$$.int_val = std::min($1.int_val, $2.int_val);

internal-op MinD
type VVC
eval	$$.double_val = std::min($1.double_val, $2.double_val);

internal-op MinU
type VVV
eval	$$.uint_val = std::min($1.uint_val, $2.uint_val);

internal-op MinI
type VVV
eval	$$.int_val = std::min($1.int_val, $2.int_val);

internal-op MinD
type VVV
eval	$$.double_val = std::min($1.double_val, $2.double_val);

internal-op MaxU
type VVC
eval	$$.uint_val = std::max($1.uint_val, $2.uint_val);

internal-op MaxI
type VVC
eval	$$.int_val = std::max($1.int_val, $2.int_val);

internal-op MaxD
type VVC
eval	$$.double_val = std::max($1.double_val, $2.double_val);

internal-op MaxU
type VVV
eval	$$.uint_val = std::max($1.uint_val, $2.uint_val);

internal-op MaxI
type VVV
eval	$$.int_val = std::max($1.int_val, $2.int_val);

internal-op MaxD
type VVV
eval	$$.double_val = std::max($1.double_val, $2.double_val);
