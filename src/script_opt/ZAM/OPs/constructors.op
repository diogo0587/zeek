# Operations corresponding to aggregated constructors.

# Table construction requires atypical evaluation of list elements
# using information from their expression specifics.
direct-unary-op Table-Constructor ConstructTable

macro ConstructTableOrSetPre(width)
	auto tt = cast_intrusive<TableType>(Z_TYPE);
	auto new_t = new TableVal(tt, Z_AUX->attrs);
	auto aux = Z_AUX;
	auto n = aux->n;
	auto ind_width = width;

macro ConstructTableOrSetPost(lhs)
	auto& t = lhs.table_val;
	Unref(t);
	t = new_t;

internal-op Construct-Table
type Vi
eval	ConstructTableOrSetPre($1)
	for ( auto i = 0; i < n; ++i )
		{
		auto indices = aux->ToIndices(frame, i, ind_width);
		auto v = aux->ToVal(frame, i + ind_width);
		new_t->Assign(indices, v);
		i += ind_width;
		}
	ConstructTableOrSetPost($$)

# When tables are constructed, if their &default is a lambda with captures
# then we need to explicitly set up the default.
internal-op Set-Table-Default-Lambda
type VV
op1-read
eval	auto& tbl = $1.table_val;
	auto lambda = $2.ToVal(Z_TYPE);
	tbl->InitDefaultVal(std::move(lambda));

direct-unary-op Set-Constructor ConstructSet

internal-op Construct-Set
type Vi
eval	ConstructTableOrSetPre($1)
	for ( auto i = 0; i < n; i += ind_width )
		{
		auto indices = aux->ToIndices(frame, i, ind_width);
		new_t->Assign(indices, nullptr);
		}
	ConstructTableOrSetPost($$)

direct-unary-op Record-Constructor ConstructRecord

macro ConstructRecordPost(lhs)
	auto& r = lhs.record_val;
	Unref(r);
	r = new RecordVal(cast_intrusive<RecordType>(Z_TYPE), std::move(init_vals));

op Construct-Direct-Record
type V
eval	auto init_vals = Z_AUX->ToZValVec(frame);
	ConstructRecordPost($$)

op Construct-Known-Record
type V
eval	auto init_vals = Z_AUX->ToZValVecWithMap(frame);
	ConstructRecordPost($$)

op Construct-Known-Record-With-NT
type Vi
eval	auto init_vals = Z_AUX->ToZValVecWithMap(frame);
	ASSERT(! init_vals[$1]);
	init_vals[$1] = ZVal(run_state::network_time);
	ConstructRecordPost($$)

op Construct-Known-Record-With-Inits
type V
eval	auto init_vals = Z_AUX->ToZValVecWithMap(frame);
	for ( auto& fi : *Z_AUX->field_inits )
		init_vals[fi.first] = fi.second->Generate();
	ConstructRecordPost($$)

op Construct-Known-Record-With-Inits-And-NT
type Vi
eval	auto init_vals = Z_AUX->ToZValVecWithMap(frame);
	for ( auto& fi : *Z_AUX->field_inits )
		init_vals[fi.first] = fi.second->Generate();
	ASSERT(! init_vals[$1]);
	init_vals[$1] = ZVal(run_state::network_time);
	ConstructRecordPost($$)

# Special instruction for concretizing vectors that are fields in a
# newly-constructed record. "aux" holds which fields in the record to
# inspect.
op Concretize-Vector-Fields
op1-read
type V
eval	auto rt = cast_intrusive<RecordType>(Z_TYPE);
	auto r = $1.record_val;
	auto aux = Z_AUX;
	auto n = aux->n;
	for ( auto i = 0; i < n; ++i )
		{
		auto ind = aux->elems[i].IntVal();
		auto v_i = r->GetField(ind);
		ASSERT(v_i);
		if ( v_i->GetType<VectorType>()->IsUnspecifiedVector() )
			{
			const auto& t_i = rt->GetFieldType(ind);
			v_i->AsVectorVal()->Concretize(t_i->Yield());
			}
		}

direct-unary-op Vector-Constructor ConstructVector

internal-op Construct-Vector
type V
eval	auto new_vv = new VectorVal(cast_intrusive<VectorType>(Z_TYPE));
	auto aux = Z_AUX;
	auto n = aux->n;
	for ( auto i = 0; i < n; ++i )
		new_vv->Assign(i, aux->ToVal(frame, i));
	auto& vv = $$.vector_val;
	Unref(vv);
	vv = new_vv;
