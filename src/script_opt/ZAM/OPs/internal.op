# Internal operations not directly driven off of AST elements.

# These two are only needed for type-based switch statements.  Could think
# about replacing them using CoerceFromAnyExpr.
op Assign-Any
types VV VC
set-type $1
eval	auto v = $1.ToVal(Z_TYPE);
	$$.any_val = v.release();

# Lazy way to assign without having to track the specific type of
# a constant.
internal-op Assign-Const
type VC
eval	AssignTarget($$, BuildVal($1.ToVal(Z_TYPE), Z_TYPE))

internal-assignment-op Load-Val
type Vi
assign-val v
eval	auto& v = f->GetElement($1);

internal-assignment-op Load-Global
type Vi
assign-val v
eval	auto& v = globals[$1].id->GetVal();
	if ( ! v )
		{
		ZAM_run_time_error(Z_LOC, "value used but not set", Z_AUX->id_val.get());
		break;
		}

# We need a special form here for loading global types, as they don't
# fit the usual template.
internal-op Load-Global-Type
type Vi
eval	auto& v = $$.type_val;
	Unref(v);
	auto& t = globals[$1].id->GetType();
	v = new TypeVal(t, true);

internal-op Load-Capture
type Vi
eval	$$ = f->GetFunction()->GetCapturesVec()[$1];

internal-op Load-Managed-Capture
type Vi
eval	auto& lhs = $$;
	auto& rhs = f->GetFunction()->GetCapturesVec()[$1];
	zeek::Ref(rhs.ManagedVal());
	ZVal::DeleteManagedType(lhs);
	lhs = rhs;

internal-op Store-Global
op1-internal
type i
eval	auto& g = globals[$1];
	g.id->SetVal(frame[g.slot].ToVal(Z_TYPE));

# Both of these have the LHS as v2 not v1, to keep with existing
# conventions of OP_VV_I2 op type (as opposed to OP_VV_I1_V2, which doesn't
# currently exist, and would be a pain to add).
internal-op Store-Capture
op1-read
type Vi
eval	f->GetFunction()->GetCapturesVec()[$2] = $1;

internal-op Store-Managed-Capture
op1-read
type Vi
eval	auto& lhs = f->GetFunction()->GetCapturesVec()[$2];
	auto& rhs = $1;
	zeek::Ref(rhs.ManagedVal());
	ZVal::DeleteManagedType(lhs);
	lhs = rhs;


internal-op Copy-To
type VC
set-type $1
eval	AssignTarget($$, CopyVal($1))

internal-op GoTo
type i
eval	BRANCH($1)

internal-op Hook-Break
type X
eval	flow = FLOW_BREAK;
	pc = end_pc;
	DO_ZAM_PROFILE
	continue;

# Slot 2 gives frame size.
internal-op Lambda
type Vi
eval	auto& aux = Z_AUX;
	auto& primary_func = aux->primary_func;
	auto& body = primary_func->GetBodies()[0].stmts;
	ASSERT(body->Tag() == STMT_ZAM);
	auto lamb = make_intrusive<ScriptFunc>(aux->id_val);
	lamb->AddBody(body, $1);
	lamb->SetName(aux->lambda_name.c_str());
	if ( aux->n > 0 )
		{
		auto captures = std::make_unique<std::vector<ZVal>>();
		for ( auto i = 0; i < aux->n; ++i )
			{
			auto slot = aux->elems[i].Slot();
			if ( slot >= 0 )
				{
				auto& cp = frame[slot];
				if ( aux->elems[i].IsManaged() )
					zeek::Ref(cp.ManagedVal());
				captures->push_back(cp);
				}
			else
				/* Used for when-locals. */
				captures->push_back(ZVal());
			}
		lamb->CreateCaptures(std::move(captures));
		}
	ZVal::DeleteManagedType($$);
	$$.func_val = lamb.release();
