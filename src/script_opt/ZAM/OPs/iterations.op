# Operations corresponding to iterations.

internal-op Init-Table-Loop
type Vi
op1-read
eval	auto& ti = (*tiv_ptr)[$2];
	ti.BeginLoop({NewRef{}, $1.table_val}, Z_AUX);

internal-op Next-Table-Iter
op1-read
# v1 = iteration info
# v2 = branch target if loop done
type ii
eval	NextTableIterPre($1, $2)
	ti.NextIter(frame);

macro NextTableIterPre(iter, branch)
	auto& ti = (*tiv_ptr)[iter];
	if ( ti.IsDoneIterating() )
		BRANCH(branch)

internal-op Next-Table-Iter-No-Vars
op1-read
# v1 = iteration info
# v2 = branch target if loop done
type ii
eval	NextTableIterPre($1, $2)
	ti.IterFinished();

internal-op Next-Table-Iter-Val-Var
# v1 = slot of the "ValueVar"
# v2 = iteration info
# v3 = branch target if loop done
type Vii
eval	NextTableIterPre($1, $2)
	AssignTarget($$, ti.IterValue());
	ti.NextIter(frame);

internal-op Next-Table-Iter-Val-Var-No-Vars
# v1 = slot of the "ValueVar"
# v2 = iteration info
# v3 = branch target if loop done
type Vii
eval	NextTableIterPre($1, $2)
	AssignTarget($$, ti.IterValue());
	ti.IterFinished();


internal-op Init-Vector-Loop
type Vi
op1-read
eval	auto& vv = $1.vector_val->RawVec();
	step_iters[$2].InitLoop(&vv);

macro NextVectorIterCore(info, branch)
	auto& si = step_iters[info];
	if ( si.IsDoneIterating() )
		BRANCH(branch)
	const auto& vv = *si.vv;
	if ( ! vv[si.iter] )
		{ /* Account for vector hole.  Re-execute for next position. */
		si.IterFinished();
		--pc;	/* so we then increment to here again */
		break;
		}

internal-op Next-Vector-Iter
# v1 = iteration variable
# v2 = iteration info
# v3 = branch target if loop done
type Vii
eval	NextVectorIterCore($1, $2)
	$$.uint_val = si.iter;
	si.IterFinished();

internal-op Next-Vector-Blank-Iter
# v1 = iteration info
# v2 = branch target if loop done
op1-internal
type ii
eval	NextVectorIterCore($1, $2)
	si.IterFinished();

internal-op Next-Vector-Iter-Val-Var
# v1 = iteration variable
# v2 = value variable
# v3 = iteration info
# v4 = branch target if loop done
op1-read-write
type VVii
eval	NextVectorIterCore($2, $3)
	$$.uint_val = si.iter;
	if ( Z_IS_MANAGED )
		$1 = BuildVal(vv[si.iter]->ToVal(Z_TYPE), Z_TYPE);
	else
		$1 = *vv[si.iter];
	si.IterFinished();

internal-op Next-Vector-Blank-Iter-Val-Var
# v1 = value variable
# v2 = iteration info
# v3 = branch target if loop done
type Vii
eval	NextVectorIterCore($1, $2)
	if ( Z_IS_MANAGED )
		$$ = BuildVal(vv[si.iter]->ToVal(Z_TYPE), Z_TYPE);
	else
		$$ = *vv[si.iter];
	si.IterFinished();


internal-op Init-String-Loop
types Vi Ci
op1-read
eval	step_iters[$2].InitLoop($1.string_val->AsString());

internal-op Next-String-Iter
# v1 = iteration variable
# v2 = iteration info
# v3 = branch target if loop done
type Vii
eval	auto& si = step_iters[$1];
	if ( si.IsDoneIterating() )
		BRANCH($2)
	auto bytes = (const char*) si.s->Bytes() + si.iter;
	auto sv = new StringVal(1, bytes);
	Unref($$.string_val);
	$$.string_val = sv;
	si.IterFinished();

internal-op Next-String-Blank-Iter
# v1 = iteration info
# v2 = branch target if loop done
op1-internal
type ii
eval	auto& si = step_iters[$1];
	if ( si.IsDoneIterating() )
		BRANCH($2)
	si.IterFinished();

internal-op End-Table-Loop
op1-internal
type i
eval	(*tiv_ptr)[$1].Clear();
